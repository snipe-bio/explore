<!DOCTYPE html>
<html lang="en">

<head>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VNXC3S1LH2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-VNXC3S1LH2');
    </script>

    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-N5RW3TB3');</script>
    <!-- End Google Tag Manager -->

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snipe SRA Exploration Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.6.3/nouislider.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.6.3/nouislider.min.js"></script>


    <!-- Driver.js CSS and JS -->
    <script src="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.js.iife.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.css" />
    <link rel="stylesheet" href="styles/styles.css">
    <script src="scripts/snipe-explore.js"></script>

</head>


<!-- Help Modal -->
<div id="help-modal" class="modal">
    <div class="modal-content">
        <span id="close-modal" class="close-button">&times;</span>
        <h2>Snipe metrics description</h2>
        <div id="modal-column-definitions">
            <!-- Column definitions will be inserted here -->
        </div>
    </div>
</div>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N5RW3TB3" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <!-- Updated Species and Reference Selection with Amplicon -->
    <div class="container">
        <h1>Snipe SRA Exploration Dashboard</h1>
        <div id="data-selection-container" class="species-selection">
            <div class="control-group">
                <label for="species-select">Species:</label>
                <select id="species-select">
                    <option value="">Select Species</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            <div class="control-group">
                <label for="reference-select">Reference Genome:</label>
                <select id="reference-select" disabled>
                    <option value="">Select Reference Genome</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            <div class="control-group">
                <label for="amplicon-select">Amplicon:</label>
                <select id="amplicon-select" disabled>
                    <option value="">Select Amplicon:</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            <div class="control-group">
                <button id="load-data-button" disabled>Load Data</button>
            </div>
            <div id="log-info" class="log-info" style="display: none;">
                <!-- Log information will be displayed here -->
            </div>
        </div>



        <div id="plots-container"></div>

        <div id="add-view-container" style="display: none;">
            <button id="add-view" class="add-view-button">
                <i class="fa fa-plus-circle"></i> Add View
            </button>
        </div>

        <div id="data-selection-section">
            <h2>Selected Data Points</h2>
            <div id="table-container" class="table-container"></div>
        </div>
    </div>


    <div class="floating-buttons">
        <button id="clear-selections" class="floating-button">
            <i class="fa fa-eraser"></i>
            <span>Clear Selections</span>
        </button>
        <button id="export-table" class="floating-button">
            <i class="fa fa-file-export"></i>
            <span>Export Table (TSV)</span>
        </button>
        <button id="export-pdf" class="floating-button">
            <i class="fa fa-file-pdf"></i>
            <span>Export Snipe Report</span>
        </button>
        <button id="scroll-to-table" class="floating-button">
            <i class="fa fa-arrow-down"></i>
            <span>Scroll to Table</span>
        </button>

        <button id="help-button" class="floating-button">
            <i class="fa-solid fa-circle-question"></i>
            <span>Snipe metrics definitions</span>
        </button>

        <!-- driverJS -->
        <button id="start-tour" class="floating-button">
            <i class="fa fa-book"></i>
            <span>Start Tour</span>
        </button>
        <!-- New Import/Export Session Buttons -->
        <button id="export-session" class="floating-button">
            <i class="fa fa-download"></i>
            <span>Export Session</span>
        </button>
        <button id="import-session" class="floating-button">
            <i class="fa fa-upload"></i>
            <span>Import Session</span>
        </button>

        <button id="export-session-url" class="floating-button">
            <i class="fa fa-link"></i>
            <span>Export Session to URL</span>
        </button>
        <button id="upload-data" class="floating-button">
            <i class="fa fa-upload"></i>
            <span>Upload Data</span>
        </button>

    </div>

    <script>
        let data = [];
        let currentPlotData = [];
        let selectedPoints = [];
        let plotsContainer, tableContainer, exportTableButton, clearSelectionsButton, addViewButton;
        let plotCounter = 0;
        let snipe_metadata = {};

        let uploadStats = {
            totalNewExperiments: 0,
            totalUpdatedExperiments: 0,
            lastUploadTimestamp: null
        };

        const species_genome_amplicon_path = {
            'Canine': {
                'CanFam3.1': {
                    'Exome': 'https://raw.githubusercontent.com/snipe-bio/dbs/refs/heads/main/qc_tables/Dog/canfam31_ychr_exome_rna_gtdb.tsv'
                }
            },
            'Cattle': {
                'ARS-UCD2.0': {
                    'Exome': 'https://raw.githubusercontent.com/snipe-bio/dbs/refs/heads/main/qc_tables/Cattle/cattle_arsucd20_exome_rna_gtdb.tsv'
                }
            },
            'Human': {
                'CHM13v2': {
                    'Exome': 'https://raw.githubusercontent.com/snipe-bio/dbs/refs/heads/main/qc_tables/Human/human_chm13v2_exome_rna_gtdb.tsv'
                }
            },
            "Mouse": {
                "GRCm39": {
                    "Exome": "https://raw.githubusercontent.com/snipe-bio/dbs/refs/heads/main/qc_tables/Mouse/mouse_grcm39_exome_rna_gtdb.tsv"
                },
            },
            "Arabidopsis": {
                "TAIR10.1": {
                    "Exome": "https://raw.githubusercontent.com/snipe-bio/dbs/refs/heads/main/qc_tables/Arabidopsis/arabidopsis_snipe_TAIR10.1_exome_rna_gtdb.tsv"
                }
            },
        };

        document.addEventListener('DOMContentLoaded', function () {
            // Get references to the elements
            const speciesSelect = document.getElementById('species-select');
            const referenceSelect = document.getElementById('reference-select');
            const ampliconSelect = document.getElementById('amplicon-select');
            const loadDataButton = document.getElementById('load-data-button');
            const dataSelectionContainer = document.getElementById('data-selection-container');

            plotsContainer = document.getElementById('plots-container');
            tableContainer = document.getElementById('table-container');
            exportTableButton = document.getElementById('export-table');
            clearSelectionsButton = document.getElementById('clear-selections');
            addViewButton = document.getElementById('add-view');

            exportTableButton.addEventListener('click', exportTableToTSV);
            clearSelectionsButton.addEventListener('click', clearSelections);
            addViewButton.addEventListener('click', addNewPlot);
            document.getElementById('export-pdf').addEventListener('click', exportAllDataAsPDF);
            document.getElementById('scroll-to-table').addEventListener('click', scrollToTable);

            // Populate species options
            for (const species in species_genome_amplicon_path) {
                const option = document.createElement('option');
                option.value = species;
                option.textContent = species;
                speciesSelect.appendChild(option);
            }

            // Set default selected species
            speciesSelect.value = 'Canine';

            // Event listener for species select
            speciesSelect.addEventListener('change', function () {
                const selectedSpecies = speciesSelect.value;

                // Clear previous reference options
                referenceSelect.innerHTML = '<option value="">Select Reference Genome</option>';
                referenceSelect.disabled = true;

                // Clear amplicon options
                ampliconSelect.innerHTML = '<option value="">Select Amplicon (Optional)</option>';
                ampliconSelect.disabled = true;

                loadDataButton.disabled = true;

                // Clear data and plots
                clearAllData();

                if (selectedSpecies) {
                    const references = species_genome_amplicon_path[selectedSpecies];
                    for (const reference in references) {
                        const option = document.createElement('option');
                        option.value = reference;
                        option.textContent = reference;
                        referenceSelect.appendChild(option);
                    }
                    referenceSelect.disabled = false;

                    // Set default selected reference
                    referenceSelect.value = 'CanFam3.1';

                    // Trigger change event to populate amplicon
                    referenceSelect.dispatchEvent(new Event('change'));
                }
            });

            // Event listener for reference select
            referenceSelect.addEventListener('change', function () {
                const selectedSpecies = speciesSelect.value;
                const selectedReference = referenceSelect.value;

                // Clear previous amplicon options
                ampliconSelect.innerHTML = '<option value="">Select Amplicon (Optional)</option>';
                ampliconSelect.disabled = true;

                loadDataButton.disabled = true;

                // Clear data and plots
                clearAllData();

                if (selectedReference) {
                    const amplicons = species_genome_amplicon_path[selectedSpecies][selectedReference];
                    for (const amplicon in amplicons) {
                        const option = document.createElement('option');
                        option.value = amplicon;
                        option.textContent = amplicon === '' ? 'No Amplicon' : amplicon;
                        ampliconSelect.appendChild(option);
                    }
                    ampliconSelect.disabled = false;

                    // Set default selected amplicon
                    ampliconSelect.value = 'Amplicon';

                    // Trigger change event to enable load data button
                    ampliconSelect.dispatchEvent(new Event('change'));
                }
            });

            // Event listener for amplicon select
            ampliconSelect.addEventListener('change', function () {
                const selectedSpecies = speciesSelect.value;
                const selectedReference = referenceSelect.value;
                const selectedAmplicon = ampliconSelect.value;

                const dataFilePath = species_genome_amplicon_path[selectedSpecies][selectedReference][selectedAmplicon];

                // Clear data and plots
                clearAllData();

                if (dataFilePath) {
                    loadDataButton.disabled = false;
                } else {
                    loadDataButton.disabled = true;
                }
            });

            // Event listener for load data button
            loadDataButton.addEventListener('click', function () {
                const selectedSpecies = speciesSelect.value;
                const selectedReference = referenceSelect.value;
                const selectedAmplicon = ampliconSelect.value;

                const dataFilePath = species_genome_amplicon_path[selectedSpecies][selectedReference][selectedAmplicon];

                if (dataFilePath) {
                    loadData(dataFilePath);
                    loadDataButton.disabled = true;
                } else {
                    alert('Data not available for selected species, reference genome, and amplicon.');
                }
            });

            // Event listeners for the new buttons
            document.getElementById('export-session').addEventListener('click', exportSession);

            // Event listener for the Export Session to URL button
            document.getElementById('export-session-url').addEventListener('click', exportSessionToURL);

            // Check if there's session data or user data in the URL
            const urlParams = new URLSearchParams(window.location.search);
            const sessionDataEncoded = urlParams.get('session');
            const dataEncoded = urlParams.get('data');

            let userData = null;
            if (dataEncoded) {
                const dataJSON = LZString.decompressFromEncodedURIComponent(dataEncoded);
                if (dataJSON) {
                    userData = JSON.parse(dataJSON);
                } else {
                    alert('Failed to load data from URL.');
                }
            }

            if (sessionDataEncoded) {
                // Case 1 or 3: Session URL present
                const sessionDataJSON = LZString.decompressFromEncodedURIComponent(sessionDataEncoded);
                if (sessionDataJSON) {
                    importSession(sessionDataJSON, userData);
                    if (userData) {
                        // Hide data selection since user data is provided
                        dataSelectionContainer.style.display = 'none';
                    }
                } else {
                    alert('Failed to load session from URL.');
                }
            } else if (userData) {
                // Case 2: Only data URL present
                dataSelectionContainer.style.display = 'none'; // Hide data selection
                loadUserData(userData);
            } else {
                speciesSelect.dispatchEvent(new Event('change'));
            }

            // Attach event listener to the "Start Tour" button
            const startTourButton = document.getElementById('start-tour');
            startTourButton.addEventListener('click', function () {
                startTour();
            });

            const helpButton = document.getElementById('help-button');
            const helpModal = document.getElementById('help-modal');
            const closeModalButton = document.getElementById('close-modal');

            helpButton.addEventListener('click', function () {
                helpModal.style.display = 'flex'; // Show the modal using flex layout
            });

            closeModalButton.addEventListener('click', function () {
                helpModal.style.display = 'none'; // Hide the modal
            });

            window.addEventListener('click', function (event) {
                if (event.target === helpModal) {
                    helpModal.style.display = 'none'; // Hide modal when clicking outside the content
                }
            });

            // Event listener for the Import Session button
            document.getElementById('import-session').addEventListener('click', function () {
                const importSessionModal = document.getElementById('import-session-modal');
                importSessionModal.style.display = 'flex';
            });

            // Event listener for the close button in the modal
            document.getElementById('import-session-close').addEventListener('click', function () {
                const importSessionModal = document.getElementById('import-session-modal');
                importSessionModal.style.display = 'none';
            });

            // Event listener for the Import Session confirm button
            document.getElementById('import-session-confirm').addEventListener('click', function () {
                const fileInput = document.getElementById('session-file-input');
                const textarea = document.getElementById('session-textarea');
                if (fileInput.files.length > 0) {
                    // Read the file
                    const file = fileInput.files[0];
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const jsonData = e.target.result;
                        importSession(jsonData);
                        // Close the modal
                        document.getElementById('import-session-modal').style.display = 'none';

                        // Show notification
                        showNotification('Session imported successfully.');
                    };
                    reader.readAsText(file);
                } else if (textarea.value.trim() !== '') {
                    // Use the pasted data
                    const jsonData = textarea.value.trim();
                    importSession(jsonData);
                    // Close the modal
                    document.getElementById('import-session-modal').style.display = 'none';

                    // Show notification
                    showNotification('Session imported successfully.');
                } else {
                    alert('Please upload a session file or paste session data.');
                }
            });

            // Close modal when clicking outside of it
            window.addEventListener('click', function (event) {
                const importSessionModal = document.getElementById('import-session-modal');
                if (event.target === importSessionModal) {
                    importSessionModal.style.display = 'none';
                }
            });

            // Event listener for the Export Session to URL button
            document.getElementById('export-session-url').addEventListener('click', exportSessionToURL);

            // Event listener for the close button in the modal
            document.getElementById('export-session-url-close').addEventListener('click', function () {
                const exportSessionUrlModal = document.getElementById('export-session-url-modal');
                exportSessionUrlModal.style.display = 'none';
            });

            // Event listener for the copy to clipboard button
            document.getElementById('copy-session-url').addEventListener('click', function () {
                const sessionUrlInput = document.getElementById('session-url-input');
                sessionUrlInput.select();
                sessionUrlInput.setSelectionRange(0, 99999);

                document.execCommand('copy');

                // Show a notification
                showNotification('Session URL copied to clipboard.');
            });

            // Close modal when clicking outside of it
            window.addEventListener('click', function (event) {
                const exportSessionUrlModal = document.getElementById('export-session-url-modal');
                if (event.target === exportSessionUrlModal) {
                    exportSessionUrlModal.style.display = 'none';
                }
            });

            // Event listener for the Upload Data button
            document.getElementById('upload-data').addEventListener('click', function () {
                const uploadDataModal = document.getElementById('upload-data-modal');
                uploadDataModal.style.display = 'flex';
            });

            // Event listener for the close button in the upload data modal
            document.getElementById('upload-data-close').addEventListener('click', function () {
                const uploadDataModal = document.getElementById('upload-data-modal');
                uploadDataModal.style.display = 'none';
            });

            // Close modal when clicking outside of it
            window.addEventListener('click', function (event) {
                const uploadDataModal = document.getElementById('upload-data-modal');
                if (event.target === uploadDataModal) {
                    uploadDataModal.style.display = 'none';
                }
            });

            // Event listener for the Upload Data confirm button
            document.getElementById('upload-data-confirm').addEventListener('click', function () {
                const fileInput = document.getElementById('upload-data-file-input');
                const uploadMode = document.querySelector('input[name="upload-data-mode"]:checked').value;

                if (fileInput.files.length > 0) {
                    // Read the file
                    const file = fileInput.files[0];
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const tsvData = e.target.result;
                        parseAndLoadUserData(tsvData, uploadMode);
                        document.getElementById('upload-data-modal').style.display = 'none';
                    };
                    reader.readAsText(file);
                } else {
                    alert('Please select a TSV file to upload.');
                }
            });

            // Close modal when clicking outside of it
            window.addEventListener('click', function (event) {
                const uploadDataModal = document.getElementById('upload-data-modal');
                if (event.target === uploadDataModal) {
                    uploadDataModal.style.display = 'none';
                }
            });

            tableContainer.addEventListener('click', function (event) {
                event.preventDefault(); // Prevent default link behavior

                // Show Depth per Chromosome
                if (event.target && event.target.classList.contains('show-depth')) {
                    const uniqueId = event.target.getAttribute('data-unique-id');
                    const selectedData = data.find(row => row._uniqueId === uniqueId);
                    if (selectedData) {
                        plot_depth_per_chromosome(selectedData);
                    } else {
                        alert('Data not found for the selected Experiment.');
                    }
                }

                // Purge Experiment
                if (event.target && event.target.classList.contains('purge-experiment')) {
                    const uniqueId = event.target.getAttribute('data-unique-id');
                    purgeExperiment(uniqueId);
                }

                // Purge BioProject
                if (event.target && event.target.classList.contains('purge-bioproject')) {
                    const bioProject = event.target.getAttribute('data-bioproject');
                    purgeBioProject(bioProject);
                }

                // Purge BioSample
                if (event.target && event.target.classList.contains('purge-biosample')) {
                    const bioSample = event.target.getAttribute('data-biosample');
                    purgeBioSample(bioSample);
                }

                if (event.target && event.target.classList.contains('view-sra')) {
                    const uniqueId = event.target.getAttribute('data-unique-id');
                    const selectedData = data.find(row => row._uniqueId === uniqueId);
                    if (selectedData && selectedData['Experiment ID']) {
                        const sraUrl = `https://ncbi.nlm.nih.gov/sra/${selectedData['Experiment ID']}`;
                        window.open(sraUrl, '_blank', 'noopener,noreferrer');
                    } else {
                        alert('Experiment ID not found for the selected Experiment.');
                    }
                }

            });

            // Event listeners to search for experiments by URL
            // Check for sra-exp, bioproject, biosample, and species in URL
            const sraExp = urlParams.get('sra-exp');
            const bioproject = urlParams.get('bioproject');
            const biosample = urlParams.get('biosample');
            const speciesParam = urlParams.get('species');

            if ((sraExp || bioproject || biosample) && speciesParam) {
                // Set speciesSelect to speciesParam
                speciesSelect.value = speciesParam;
                speciesSelect.dispatchEvent(new Event('change'));

                setTimeout(() => {
                    const selectedSpecies = speciesSelect.value;
                    const references = species_genome_amplicon_path[selectedSpecies];
                    const defaultReference = Object.keys(references)[0];
                    referenceSelect.value = defaultReference;
                    referenceSelect.dispatchEvent(new Event('change'));

                    setTimeout(() => {
                        const selectedReference = referenceSelect.value;
                        const amplicons = species_genome_amplicon_path[selectedSpecies][selectedReference];
                        const defaultAmplicon = Object.keys(amplicons)[0];
                        ampliconSelect.value = defaultAmplicon;
                        ampliconSelect.dispatchEvent(new Event('change'));

                        setTimeout(() => {
                            const dataFilePath = species_genome_amplicon_path[selectedSpecies][selectedReference][defaultAmplicon];
                            if (dataFilePath) {
                                loadData(dataFilePath, function () {
                                    // Data is loaded, now search for the Experiment ID, BioProject, or BioSample
                                    let searchTerm = null;
                                    let searchField = null;
                                    if (sraExp) {
                                        searchTerm = sraExp;
                                        searchField = 'Experiment ID';
                                    } else if (bioproject) {
                                        searchTerm = bioproject;
                                        searchField = 'BioProject';
                                    } else if (biosample) {
                                        searchTerm = biosample;
                                        searchField = 'BioSample';
                                    }

                                    // Perform case-insensitive search
                                    const matchingData = data.filter(row => row[searchField] && row[searchField].toLowerCase() === searchTerm.toLowerCase());
                                    const pointType = searchField === 'Experiment ID' ? 'Experiment' : searchField === 'BioProject' ? 'BioProject' : 'BioSample';
                                    if (matchingData.length > 0) {
                                        // Found matching data
                                        selectedPoints = selectedPoints.concat(matchingData);
                                        updateTable();
                                        highlightSelectedPoints();
                                        showModal(`${pointType} Found`, `${pointType} ${searchTerm} found and highlighted in the table. Create a new plot to visualize the data.`);
                                    } else {
                                        showModal(`${pointType} Not Found`, `${pointType} ${searchTerm} not found in the data.`);
                                    }
                                });
                                loadDataButton.disabled = true;
                            } else {
                                alert('Data not available for selected species, reference genome, and amplicon.');
                            }
                        }, 500);
                    }, 500);
                }, 500);
            }


        });

        function parseAndLoadUserData(tsvData, uploadMode) {
            // Parse the TSV data using PapaParse
            const results = Papa.parse(tsvData, {
                header: true,
                delimiter: "\t",
            });
            const userDataArray = results.data.filter(row => Object.values(row).some(value => value !== null && value !== ''));

            // Update the last upload timestamp
            const currentTimestamp = new Date().toISOString();

            if (uploadMode === 'replace') {
                // Reset cumulative stats on replace
                uploadStats = {
                    totalNewExperiments: 0,
                    totalUpdatedExperiments: 0,
                    lastUploadTimestamp: currentTimestamp
                };

                clearAllData();
                loadUserData(userDataArray);

                uploadStats.totalNewExperiments += userDataArray.length;
                showNotification(`Successfully loaded ${uploadStats.totalNewExperiments} experiments.`, 'success');
            } else if (uploadMode === 'append') {
                // Update the last upload timestamp
                uploadStats.lastUploadTimestamp = currentTimestamp;

                // Ensure existing data is present
                if (!data || data.length === 0) {
                    showNotification('Error: No existing data found to append to.', 'error');
                    return;
                }

                const existingColumns = new Set(Object.keys(data[0] || {}));
                const newColumns = new Set(Object.keys(userDataArray[0] || {}));
                const allColumns = new Set([...existingColumns, ...newColumns]);

                // Initialize missing columns in both datasets with default value null
                data.forEach(row => {
                    newColumns.forEach(col => {
                        if (!row.hasOwnProperty(col) && col !== 'Experiment ID') {
                            row[col] = null;
                        }
                    });
                });

                userDataArray.forEach(row => {
                    existingColumns.forEach(col => {
                        if (!row.hasOwnProperty(col) && col !== 'Experiment ID') {
                            row[col] = null;
                        }
                    });
                });

                // Integrate user data with existing data and get the list of new experiments
                console.log('Upload Stats Before Integration:', uploadStats);
                const newExperiments = integrateUserData(userDataArray);
                console.log('Upload Stats After Integration:', uploadStats);

                // Add newExperiments to selectedPoints
                if (newExperiments.length > 0) {
                    selectedPoints = selectedPoints.concat(newExperiments);
                    operationsLog.push(`Added ${newExperiments.length} new experiments to selected points.`);
                    console.log('Selected Points after append:', selectedPoints);
                } else {
                    console.log('No new experiments to add to selected points.');
                }

                // Update plots and table
                for (let i = 1; i <= plotCounter; i++) {
                    const plotId = `plot-${i}`;
                    updatePlot(plotId);
                }
                updateTable();
                highlightSelectedPoints();

                // Show notification with cumulative upload statistics
                displayDataStatistics();
                showNotification(
                    `Data integrated successfully: ${uploadStats.totalNewExperiments} new experiments added, ${uploadStats.totalUpdatedExperiments} existing experiments updated.`,
                    'success'
                );
            }
        }


        function displayDataStatistics() {
            const logInfoDiv = document.getElementById('log-info');
            if (!logInfoDiv) return;

            // Show the log info box
            logInfoDiv.style.display = 'block';

            const totalPoints = data.length;
            const assayTypes = [...new Set(data.map(row => row["Assay type"] || 'Unknown').filter(type => type))];
            const assayTypeCounts = assayTypes.map(type => {
                const count = data.filter(row => row["Assay type"] === type).length;
                return `\t- ${type}: ${count}`;
            }).join('\n');

            const uniqueBioProjects = new Set(data.map(row => row["BioProject"])).size;
            const uniqueExperiments = new Set(data.map(row => row["Experiment ID"])).size;

            // Prepare cumulative upload statistics
            let uploadStatsSection = '';
            if (uploadStats.lastUploadTimestamp) {
                const timestamp = new Date(uploadStats.lastUploadTimestamp).toLocaleString();
                uploadStatsSection = `
            <details style="margin-top: 0px;">
                <summary><strong>Last Upload Statistics</strong> (${timestamp})</summary>
                <pre>
            - New experiments added: ${uploadStats.totalNewExperiments}
            - Existing experiments updated: ${uploadStats.totalUpdatedExperiments}
            - Total experiments affected: ${uploadStats.totalNewExperiments + uploadStats.totalUpdatedExperiments}</pre>
            </details>`;
            }

            // Prepare metadata information
            let metadataInfo = '';
            if (snipe_metadata && Object.keys(snipe_metadata).length > 0) {
                metadataInfo = `<details style="margin-top: 0px;">
                    <summary><strong>Metadata (click to expand)</strong></summary>
                    <pre>${JSON.stringify(snipe_metadata.metadata, null, 2)}</pre></details>
                `;
            }

            // Prepare the main stats as plain text within a <div>
            const logContent = `
            - Total Data Points: ${totalPoints}
            - BioProjects: ${uniqueBioProjects}
            - Experiments: ${uniqueExperiments}
            <details style="margin-top: 0px;">
                <summary>Assay types (click to expand)</summary>
                <pre>${assayTypeCounts}</pre>
            </details>${uploadStatsSection}${metadataInfo}`;

            logInfoDiv.innerHTML = `
            Data Statistics: ${logContent}
                `.trim();
        }



        function scrollToTable() {
            const tableSection = document.getElementById('data-selection-section');
            tableSection.scrollIntoView({ behavior: 'smooth' });
        }

        // Function to clear plots and data
        function clearAllData() {
            data = null;
            currentPlotData = null;
            selectedPoints = [];
            plotsContainer.innerHTML = '';
            tableContainer.innerHTML = '';
            plotCounter = 0;
            document.getElementById('add-view-container').style.display = 'none';
        }


        function purgeExperiment(uniqueId) {
            if (!confirm('Are you sure you want to purge this Experiment? This action cannot be undone.')) {
                return;
            }
            data = data.filter(row => row._uniqueId !== uniqueId);
            selectedPoints = selectedPoints.filter(point => point._uniqueId !== uniqueId);
            updateTable();
            showNotification('Experiment purged successfully.', 'success');
        }

        function purgeBioProject(bioProject) {
            if (!confirm(`Are you sure you want to purge all Experiments under BioProject "${bioProject}"? This action cannot be undone.`)) {
                return;
            }
            data = data.filter(row => row['BioProject'] !== bioProject);
            selectedPoints = selectedPoints.filter(point => point['BioProject'] !== bioProject);
            updateTable();
            showNotification(`All Experiments under BioProject "${bioProject}" have been purged successfully.`, 'success');
        }
        function purgeBioSample(bioSample) {
            if (!confirm(`Are you sure you want to purge all Experiments under BioSample "${bioSample}"? This action cannot be undone.`)) {
                return;
            }
            data = data.filter(row => row['BioSample'] !== bioSample);
            selectedPoints = selectedPoints.filter(point => point['BioSample'] !== bioSample);
            updateTable();
            showNotification(`All Experiments under BioSample "${bioSample}" have been purged successfully.`, 'success');
        }

        function parseMetadata(headerLine) {
            try {
                const parsedHeader = JSON.parse(headerLine);
                const decompressedMetadata = decompressMetadata(parsedHeader.metadata);
                const metadataObject = JSON.parse(decompressedMetadata);
                return {
                    snipe_version: parsedHeader["snipe-version"],
                    metadata: metadataObject
                };
            } catch (e) {
                showNotification('Error parsing metadata. Please check the console for more details.', 'error');
                console.error('Error parsing metadata:', e);
                return {};
            }
        }

        function decompressMetadata(base64String) {
            return LZString.decompressFromBase64(base64String);
        }

        function loadData(filePath, callback, addInitialPlot = true) {
            const skip_columns = ["scale", "filename", "ksize"];
            dataFilePath = filePath; // Set the global dataFilePath

            // Show loading modal
            document.getElementById('loading-modal').style.display = 'flex';

            Papa.parse(dataFilePath, {
                download: true,
                header: false, // Disable header parsing to handle it manually
                delimiter: "\t",
                skipEmptyLines: true, // Skip empty lines
                complete: function (results) {
                    let dataRows = results.data;

                    // Check if the first row is a metadata comment
                    if (dataRows.length > 0 && typeof dataRows[0][0] === 'string' && dataRows[0][0].startsWith('#')) {
                        const metadataLine = dataRows[0][0].slice(1); // Remove the leading '#'
                        snipe_metadata = parseMetadata(metadataLine);
                        console.log('Metadata:', snipe_metadata);
                        dataRows.shift(); // Remove the metadata row from data
                    }

                    if (dataRows.length > 0) {
                        const headers = dataRows.shift(); // Extract headers from the second row
                        // Convert data rows into objects using the headers
                        const parsedData = dataRows.map(row => {
                            const obj = {};
                            headers.forEach((header, index) => {
                                // Exclude skipped columns
                                if (!skip_columns.includes(header)) {
                                    obj[header] = row[index];
                                }
                            });
                            return obj;
                        });

                        // Filter out any empty rows
                        const newData = parsedData.filter(row => Object.values(row).some(value => value !== null && value !== ''));

                        // Assign a unique ID to each data point based on a unique field
                        newData.forEach(row => {
                            row._uniqueId = row['Experiment ID']; // Use a unique field
                        });

                        if (data) {
                            data = data.concat(newData);
                        } else {
                            data = newData;
                        }
                    }

                    // Populate column definitions in the modal
                    populateModalColumnDefinitions();

                    // Now that data is loaded, set up the rest of the UI
                    plotsContainer = document.getElementById('plots-container');
                    tableContainer = document.getElementById('table-container');
                    exportTableButton = document.getElementById('export-table');
                    clearSelectionsButton = document.getElementById('clear-selections');
                    addViewButton = document.getElementById('add-view');

                    exportTableButton.addEventListener('click', exportTableToTSV);
                    clearSelectionsButton.addEventListener('click', clearSelections);
                    addViewButton.addEventListener('click', addNewPlot);
                    document.getElementById('export-pdf').addEventListener('click', exportAllDataAsPDF);
                    document.getElementById('scroll-to-table').addEventListener('click', scrollToTable);

                    // Initialize variables
                    plotCounter = 0;

                    // Show the add-view button
                    document.getElementById('add-view-container').style.display = 'block';

                    // Initialize and start the tour after data is loaded
                    initOnboardingTour();

                    // Hide loading modal
                    document.getElementById('loading-modal').style.display = 'none';

                    // Show notification
                    showNotification('Data loaded successfully.');

                    if (callback) callback();

                    displayDataStatistics();
                },
                error: function (error) {
                    console.error('Error parsing TSV:', error);
                    document.getElementById('loading-modal').style.display = 'none';
                    showNotification('Failed to load data.');
                }
            });
        }



        function loadUserData(userDataArray) {
            // Show the loading modal
            document.getElementById('loading-modal').style.display = 'flex';

            // Integrate user data with existing data
            integrateUserData(userDataArray);

            // Select user data points
            selectedPoints = userDataArray.slice();

            // Set up the dashboard elements
            plotsContainer = document.getElementById('plots-container');
            tableContainer = document.getElementById('table-container');
            exportTableButton = document.getElementById('export-table');
            clearSelectionsButton = document.getElementById('clear-selections');
            addViewButton = document.getElementById('add-view');

            // Attach event listeners
            exportTableButton.addEventListener('click', exportTableToTSV);
            clearSelectionsButton.addEventListener('click', clearSelections);
            addViewButton.addEventListener('click', addNewPlot);
            document.getElementById('export-pdf').addEventListener('click', exportAllDataAsPDF);
            document.getElementById('scroll-to-table').addEventListener('click', scrollToTable);

            // Initialize plot counter
            plotCounter = 0;
            document.getElementById('add-view-container').style.display = 'block';

            // Update the table and highlight selected points
            updateTable();
            highlightSelectedPoints();

            // Hide the loading modal and show a success notification
            document.getElementById('loading-modal').style.display = 'none';
            showNotification('User data loaded successfully.');
        }



        function updateCountsDisplay(plotId) {
            if (!document.getElementById(`container-${plotId}`)) {
                return;
            }

            const plotDiv = document.getElementById(plotId);
            const xAxis = document.getElementById(`x-axis-${plotId}`).value;
            const yAxis = document.getElementById(`y-axis-${plotId}`).value;

            // Ensure that both axes are selected
            if (!xAxis || !yAxis) {
                // Clear counts if axes are not selected
                document.getElementById(`points-displayed-${plotId}`).textContent = '0';
                document.getElementById(`points-selected-${plotId}`).textContent = '0';
                document.getElementById(`assay-type-counts-${plotId}`).textContent = '';
                return;
            }

            // Get the current x and y ranges from the plot's layout
            const layout = plotDiv.layout;
            const xaxisRange = layout.xaxis.range;
            const yaxisRange = layout.yaxis.range;

            // Validate axis ranges
            if (!xaxisRange || !yaxisRange) {
                // Axis ranges are not defined yet
                return;
            }

            const xMin = parseFloat(xaxisRange[0]);
            const xMax = parseFloat(xaxisRange[1]);
            const yMin = parseFloat(yaxisRange[0]);
            const yMax = parseFloat(yaxisRange[1]);

            // Start with the data after filters and axis range sliders
            let dataToUse = getFilteredData(plotId);

            // Further filter data based on current Plotly view (zoom/pan)
            if (!isNaN(xMin) && !isNaN(xMax) && !isNaN(yMin) && !isNaN(yMax)) {
                dataToUse = dataToUse.filter(row => {
                    const xValue = parseFloat(row[xAxis]);
                    const yValue = parseFloat(row[yAxis]);
                    return xValue >= xMin && xValue <= xMax && yValue >= yMin && yValue <= yMax;
                });
            }

            // **Modified Part: Ensure that dataToUse matches what Plotly is displaying**
            // Retrieve Plotly's displayed points based on current axis ranges and trace visibility
            const plotData = plotDiv.data;
            let displayedIds = new Set();

            plotData.forEach(trace => {
                // **Check if the trace is visible**
                if (trace.visible === true || trace.visible === undefined) {
                    if (trace.ids && trace.x && trace.y) {
                        trace.x.forEach((xVal, index) => {
                            const yVal = trace.y[index];
                            const id = trace.ids[index];
                            if (!isNaN(xVal) && !isNaN(yVal)) {
                                // Handle log scales if applicable
                                const isXLog = layout.xaxis.type === 'log';
                                const isYLog = layout.yaxis.type === 'log';
                                const validX = isXLog ? (xVal > 0) : true;
                                const validY = isYLog ? (yVal > 0) : true;

                                if (validX && validY) {
                                    // Adjust values if log scale is used
                                    const plotXMin = isXLog ? Math.log10(xMin) : xMin;
                                    const plotXMax = isXLog ? Math.log10(xMax) : xMax;
                                    const plotYMin = isYLog ? Math.log10(yMin) : yMin;
                                    const plotYMax = isYLog ? Math.log10(yMax) : yMax;

                                    const currentX = isXLog ? Math.log10(xVal) : xVal;
                                    const currentY = isYLog ? Math.log10(yVal) : yVal;

                                    if (currentX >= plotXMin && currentX <= plotXMax &&
                                        currentY >= plotYMin && currentY <= plotYMax) {
                                        displayedIds.add(id);
                                    }
                                }
                            }
                        });
                    }
                }
            });

            // Now, filter dataToUse to include only those with displayedIds
            const currentViewData = dataToUse.filter(row => displayedIds.has(row._uniqueId));

            // Compute counts
            const pointsDisplayed = currentViewData.length;
            const pointsSelectedInPlot = currentViewData.filter(row => selectedPoints.some(p => p._uniqueId === row._uniqueId)).length;

            // Compute points per assay type
            const assayTypeCounts = {};
            currentViewData.forEach(row => {
                const assayType = row["Assay type"] || "Unknown";
                assayTypeCounts[assayType] = (assayTypeCounts[assayType] || 0) + 1;
            });

            // Update counts display
            const pointsDisplayedElem = document.getElementById(`points-displayed-${plotId}`);
            const pointsSelectedElem = document.getElementById(`points-selected-${plotId}`);
            const assayTypeCountsElem = document.getElementById(`assay-type-counts-${plotId}`);

            if (pointsDisplayedElem) pointsDisplayedElem.textContent = pointsDisplayed;
            if (pointsSelectedElem) pointsSelectedElem.textContent = pointsSelectedInPlot;
            if (assayTypeCountsElem) assayTypeCountsElem.textContent = Object.entries(assayTypeCounts)
                .map(([type, count]) => `${type}: ${count}`)
                .join(', ');
        }



        function addNewPlot(config = {}) {
            plotCounter++;
            const plotId = `plot-${plotCounter}`;
            let plotHTML = `
                <!-- Plot Container -->
                <div class="plot-container mt-4" id="container-${plotId}">
                    <!-- Plot Frame -->
                    <div class="card">
                        <!-- Title Bar -->
                        <div class="card-header d-flex justify-content-between align-items-center bg-primary text-white py-1">
                            <!-- Left Side (Plot Type and Export) -->
                            <div class="d-flex align-items-center">
                                <!-- Plot Type Dropdown -->
                                <select id="plot-type-${plotId}" class="form-control form-control-sm mr-2" style="width: auto;">
                                    <option value="scatter">Scatter Plot</option>
                                    <option value="histogram">Histogram</option>
                                    <option value="boxplot">Boxplot</option>
                                </select>
                                <!-- Export Dropdown -->
                                <div class="dropdown">
                                    <button class="btn btn-light btn-sm dropdown-toggle" type="button" id="export-menu-${plotId}" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                        Export
                                    </button>
                                    <div class="dropdown-menu" aria-labelledby="export-menu-${plotId}">
                                        <button class="dropdown-item" id="save-as-png-${plotId}">Save as PNG</button>
                                        <button class="dropdown-item" id="export-tsv-${plotId}">Export table for current view</button>
                                        <button class="dropdown-item" id="export-selected-tsv-${plotId}">Export table for selected points in current view</button>
                                    </div>
                                </div>
                            </div>
                            <!-- Centered Plot Title -->
                            <h5 id="plot-title-display-${plotId}" class="mb-0 text-center">Plot ${plotCounter}</h5>
                            <!-- Right-Aligned Control Buttons -->
                            <div class="plot-window-controls d-flex align-items-center">
                                <!-- Info Button -->
                                <button id="info-plot-${plotId}" class="btn btn-light btn-sm mr-1 plot-info-button" title="Info" data-plot-id="${plotId}">
                                    <i class="fa fa-info-circle"></i>
                                </button>

                                <!-- Help Button -->
                                <button id="help-button-${plotId}" class="btn btn-light btn-sm mr-1" title="Help">?</button>
                                <!-- Filter Button -->
                                <button id="filter-plot-${plotId}" class="btn btn-light btn-sm mr-1" title="Filter">
                                    <i class="fa fa-filter"></i>
                                </button>
                                <!-- Minimize, Maximize, Clone, and Close -->
                                <button id="minimize-plot-${plotId}" class="btn btn-light btn-sm mr-1" title="Minimize">
                                    <i class="fa fa-minus"></i>
                                </button>
                                <button id="maximize-plot-${plotId}" class="btn btn-light btn-sm d-none mr-1" title="Maximize">
                                    <i class="fa fa-window-maximize"></i>
                                </button>
                                <button id="clone-plot-${plotId}" class="btn btn-light btn-sm mr-1" title="Clone">
                                    <i class="fa fa-clone"></i>
                                </button>
                                <button id="close-plot-${plotId}" class="btn btn-danger btn-sm" title="Close">
                                    <i class="fa fa-times"></i>
                                </button>
                            </div>
                        </div>
                        <!-- Card Body -->
                        <div class="card-body" id="body-${plotId}">
                            <!-- Dynamic Controls will be rendered here -->
                            <div id="dynamic-controls-${plotId}" class="mt-3"></div>
                            <!-- Counts Display -->
                            <div id="counts-display-${plotId}" class="counts-display mt-2">
                                <strong>Points displayed:</strong> <span id="points-displayed-${plotId}">0</span>,
                                <strong>Points selected:</strong> <span id="points-selected-${plotId}">0</span>,
                                <strong>Points per assay type:</strong> <span id="assay-type-counts-${plotId}"></span>
                            </div>
                            <!-- Plot Area -->
                            <div class="plot-area" style="position: relative;">
                                <div id="${plotId}" class="plot"></div>
                                <!-- Floating Search Button -->
                                <div class="floating-search-button" id="floating-search-button-${plotId}">
                                    <button class="search-button" id="search-button-${plotId}">
                                        <i class="fa fa-search"></i> Search by accession
                                    </button>
                                    <input type="text" class="search-input" id="search-input-${plotId}" placeholder="Search...">
                                </div>
                            </div>
                            <!-- Title, Notes, and Export Button -->
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <label for="title-${plotId}">Plot Title:</label>
                                    <input type="text" id="title-${plotId}" class="form-control" placeholder="Enter plot title...">
                                </div>
                                <div class="col-md-6">
                                    <label for="notes-${plotId}">Notes:</label>
                                    <textarea id="notes-${plotId}" class="form-control" placeholder="Enter your notes here..."></textarea>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            plotsContainer.insertAdjacentHTML('beforeend', plotHTML);

            const plotTypeSelect = document.getElementById(`plot-type-${plotId}`);
            const titleInput = document.getElementById(`title-${plotId}`);
            const plotTitleDisplay = document.getElementById(`plot-title-display-${plotId}`);

            // Set initial values if config is provided
            if (config.plotType) {
                plotTypeSelect.value = config.plotType;
            }

            // Attach event listeners
            plotTypeSelect.addEventListener('change', () => renderDynamicControls(plotId, {}));
            titleInput.addEventListener('input', () => {
                plotTitleDisplay.textContent = titleInput.value || `Plot ${plotCounter}`;
            });

            // Set title and notes if provided
            if (config.title) {
                titleInput.value = config.title;
                plotTitleDisplay.textContent = config.title;
            }
            if (config.notes) {
                document.getElementById(`notes-${plotId}`).value = config.notes;
            }

            // Render dynamic controls with config
            renderDynamicControls(plotId, config);

            // Attach event listener to the dropdown items
            document.getElementById(`save-as-png-${plotId}`).addEventListener('click', () => savePlotAsPNG(plotId));
            document.getElementById(`export-tsv-${plotId}`).addEventListener('click', () => exportCurrentViewAsTSV(plotId));
            document.getElementById(`export-selected-tsv-${plotId}`).addEventListener('click', () => exportSelectedPointsAsTSV(plotId));

            document.getElementById(`search-button-${plotId}`).addEventListener('click', () => searchAndSelectPoints(plotId));
            document.getElementById(`search-input-${plotId}`).addEventListener('keyup', function (event) {
                if (event.key === 'Enter') {
                    searchAndSelectPoints(plotId);
                }
            });

            // Event listeners for control buttons
            document.getElementById(`minimize-plot-${plotId}`).addEventListener('click', () => minimizePlot(plotId));
            document.getElementById(`maximize-plot-${plotId}`).addEventListener('click', () => maximizePlot(plotId));
            document.getElementById(`close-plot-${plotId}`).addEventListener('click', () => closePlot(plotId));
            document.getElementById(`clone-plot-${plotId}`).addEventListener('click', () => clonePlot(plotId));
            document.getElementById(`filter-plot-${plotId}`).addEventListener('click', () => openFilterModal(plotId));

            // Set plotFilters for this plot if filters are provided in config
            if (config.filters) {
                plotFilters[plotId] = config.filters;
            } else {
                plotFilters[plotId] = [];
            }

            // Initialize plot
            updatePlot(plotId);
        }



        function clonePlot(plotId) {


            // Gather the configuration of the plot with id plotId
            const plotType = document.getElementById(`plot-type-${plotId}`).value;

            const config = {
                plotType: plotType,
                title: document.getElementById(`title-${plotId}`).value,
                notes: document.getElementById(`notes-${plotId}`).value,
            };

            if (plotType === 'scatter') {
                config.xAxis = document.getElementById(`x-axis-${plotId}`).value;
                config.yAxis = document.getElementById(`y-axis-${plotId}`).value;
                config.xLogScale = document.getElementById(`x-log-scale-${plotId}`).checked;
                config.yLogScale = document.getElementById(`y-log-scale-${plotId}`).checked;
                config.hue = document.getElementById(`hue-${plotId}`).value;
                config.palette = document.getElementById(`palette-${plotId}`).value;

                // Assay types
                const assayTypeCheckboxes = document.querySelectorAll(`#assay-type-checkboxes-${plotId} input[name="assay-type-${plotId}"]`);
                config.assayTypes = Array.from(assayTypeCheckboxes).map(checkbox => ({ value: checkbox.value, checked: checkbox.checked }));

                // Sliders: x-range and y-range
                const xSlider = document.getElementById(`x-range-slider-${plotId}`);
                if (xSlider && xSlider.noUiSlider) {
                    config.xRange = xSlider.noUiSlider.get().map(Number);
                }

                const ySlider = document.getElementById(`y-range-slider-${plotId}`);
                if (ySlider && ySlider.noUiSlider) {
                    config.yRange = ySlider.noUiSlider.get().map(Number);
                }

                // Hue slider
                const hueSlider = document.getElementById(`hue-range-slider-${plotId}`);
                if (hueSlider && hueSlider.noUiSlider) {
                    config.hueRange = hueSlider.noUiSlider.get().map(Number);
                }
            }
            else if (plotType === 'histogram' || plotType === 'boxplot') {
                const numColumnCheckboxes = document.querySelectorAll(`#checkbox-group-${plotId} input[name="num-columns-${plotId}"]`);
                config.numColumns = Array.from(numColumnCheckboxes).map(checkbox => ({ value: checkbox.value, checked: checkbox.checked }));
                config.groupBy = document.getElementById(`group-by-${plotId}`).value;
                const assayTypeCheckboxes = document.querySelectorAll(`#assay-type-checkboxes-${plotId} input[name="assay-type-${plotId}"]`);
                config.assayTypes = Array.from(assayTypeCheckboxes).map(checkbox => ({ value: checkbox.value, checked: checkbox.checked }));
            }

            // Get the filters from the original plot
            const filters = plotFilters[plotId] || [];
            config.filters = JSON.parse(JSON.stringify(filters)); // Deep copy to avoid reference issues

            addNewPlot(config);

            // Scroll to the new plot
            const newPlotId = `plot-${plotCounter}`; // Assuming plotCounter has been incremented in addNewPlot
            const newPlotContainer = document.getElementById(`container-${newPlotId}`);
            if (newPlotContainer) {
                newPlotContainer.scrollIntoView({ behavior: 'smooth' });
            }
        }




        function savePlotAsPNG(plotId) {
            const plotDiv = document.getElementById(plotId);
            Plotly.toImage(plotDiv, { format: 'png', width: 1200, height: 800 }).then(function (dataUrl) {
                const link = document.createElement('a');
                link.download = `${plotId}.png`;
                link.href = dataUrl;
                link.click();
            });
        }

        function exportCurrentViewAsTSV(plotId) {
            const plotDiv = document.getElementById(plotId);
            const plotData = plotDiv.data;
            const layout = plotDiv.layout;

            // Ensure that xaxis and yaxis ranges are defined
            if (!layout || !layout.xaxis || !layout.yaxis || !layout.xaxis.range || !layout.yaxis.range) {
                alert('Cannot determine the current view range.');
                return;
            }

            const xRange = layout.xaxis.range;
            const yRange = layout.yaxis.range;

            let currentViewData = new Set();

            // Iterate over each trace in the plot
            plotData.forEach(trace => {
                // Ensure the trace has x, y, and ids
                if (trace.x && trace.y && trace.ids) {
                    trace.x.forEach((xVal, index) => {
                        const yVal = trace.y[index];
                        const id = trace.ids[index];

                        // Check if the point is within the current x and y ranges
                        if (xVal >= xRange[0] && xVal <= xRange[1] &&
                            yVal >= yRange[0] && yVal <= yRange[1]) {
                            currentViewData.add(id);
                        }
                    });
                }
            });

            // Convert the Set to an Array for easier processing
            currentViewData = Array.from(currentViewData);

            if (currentViewData.length === 0) {
                alert('No data to export in the current view. Please adjust your plot.');
                return;
            }

            // Retrieve the full data rows based on the unique IDs
            const rowsToExport = data.filter(row => currentViewData.includes(row._uniqueId));

            // Prepare TSV content
            const columns = Object.keys(rowsToExport[0]).filter(col => !col.startsWith('_'));
            let tsvContent = columns.join('\t') + '\n';

            rowsToExport.forEach(row => {
                const rowContent = columns.map(col => row[col]).join('\t');
                tsvContent += rowContent + '\n';
            });

            // Create and trigger download
            const blob = new Blob([tsvContent], { type: 'text/tab-separated-values;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `current_view_${plotId}.tsv`;
            link.click();

            // Log the export operation
            logOperation(plotId, `Exported current view: ${rowsToExport.length} points.`);
        }


        function exportTableToTSV() {
            if (selectedPoints.length === 0) {
                alert('No data to export. Please select some points first.');
                return;
            }

            const columns = Object.keys(selectedPoints[0]).filter(col => !col.startsWith('_'));
            let csvContent = columns.join('\t') + '\n';

            selectedPoints.forEach(point => {
                const row = columns.map(col => point[col]).join('\t');
                csvContent += row + '\n';
            });

            const blob = new Blob([csvContent], { type: 'text/tab-separated-values;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'selected_points.tsv';
            link.click();

            // Show notification
            showNotification('Table exported successfully.');
        }

        function exportSelectedPointsAsTSV(plotId) {
            const plotDiv = document.getElementById(plotId);
            const plotData = plotDiv.data;
            const layout = plotDiv.layout;

            // Ensure that xaxis and yaxis ranges are defined
            if (!layout || !layout.xaxis || !layout.yaxis || !layout.xaxis.range || !layout.yaxis.range) {
                alert('Cannot determine the current view range.');
                return;
            }

            const xRange = layout.xaxis.range;
            const yRange = layout.yaxis.range;

            let visibleSelectedIds = new Set();

            // Iterate over each trace in the plot
            plotData.forEach(trace => {
                // Ensure the trace has x, y, and ids
                if (trace.x && trace.y && trace.ids) {
                    trace.x.forEach((xVal, index) => {
                        const yVal = trace.y[index];
                        const id = trace.ids[index];

                        // Check if the point is within the current x and y ranges and is selected
                        if (xVal >= xRange[0] && xVal <= xRange[1] &&
                            yVal >= yRange[0] && yVal <= yRange[1] &&
                            selectedPoints.some(p => p._uniqueId === id)) {
                            visibleSelectedIds.add(id);
                        }
                    });
                }
            });

            // Convert the Set to an Array for easier processing
            visibleSelectedIds = Array.from(visibleSelectedIds);

            if (visibleSelectedIds.length === 0) {
                alert('No selected points to export in the current view.');
                return;
            }

            // Retrieve the full data rows based on the unique IDs
            const rowsToExport = data.filter(row => visibleSelectedIds.includes(row._uniqueId));

            // Prepare TSV content
            const columns = Object.keys(rowsToExport[0]).filter(col => !col.startsWith('_'));
            let tsvContent = columns.join('\t') + '\n';

            rowsToExport.forEach(row => {
                const rowContent = columns.map(col => row[col]).join('\t');
                tsvContent += rowContent + '\n';
            });

            // Create and trigger download
            const blob = new Blob([tsvContent], { type: 'text/tab-separated-values;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `selected_points_${plotId}.tsv`;
            link.click();

            // Log the export operation
            logOperation(plotId, `Exported selected points: ${rowsToExport.length} points.`);
        }


        function getFilteredData(plotId) {
            const xAxis = document.getElementById(`x-axis-${plotId}`).value;
            const yAxis = document.getElementById(`y-axis-${plotId}`).value;

            const xSlider = document.getElementById(`x-range-slider-${plotId}`);
            const ySlider = document.getElementById(`y-range-slider-${plotId}`);

            let xMin = null, xMax = null, yMin = null, yMax = null;

            if (xSlider && xSlider.noUiSlider) {
                const xRange = xSlider.noUiSlider.get();
                xMin = parseFloat(xRange[0]);
                xMax = parseFloat(xRange[1]);
            }

            if (ySlider && ySlider.noUiSlider) {
                const yRange = ySlider.noUiSlider.get();
                yMin = parseFloat(yRange[0]);
                yMax = parseFloat(yRange[1]);
            }

            // Filter data based on X and Y ranges and selection
            return currentPlotData.filter(row => {
                const xValue = parseFloat(row[xAxis]);
                const yValue = parseFloat(row[yAxis]);
                return !isNaN(xValue) && xValue >= xMin && xValue <= xMax && !isNaN(yValue) && yValue >= yMin && yValue <= yMax;
            });
        }

        function minimizePlot(plotId) {
            const body = document.getElementById(`body-${plotId}`);
            const minimizeButton = document.getElementById(`minimize-plot-${plotId}`);
            const maximizeButton = document.getElementById(`maximize-plot-${plotId}`);

            body.style.display = 'none';
            minimizeButton.classList.add('d-none');
            maximizeButton.classList.remove('d-none');
        }

        function maximizePlot(plotId) {
            const body = document.getElementById(`body-${plotId}`);
            const minimizeButton = document.getElementById(`minimize-plot-${plotId}`);
            const maximizeButton = document.getElementById(`maximize-plot-${plotId}`);

            body.style.display = 'block';
            minimizeButton.classList.remove('d-none');
            maximizeButton.classList.add('d-none');
        }

        function closePlot(plotId) {
            const plotContainer = document.getElementById(`container-${plotId}`);
            if (plotContainer) {
                // Remove the plot container from the DOM
                plotContainer.remove();
            }
        }

        function renderDynamicControls(plotId, config = {}) {
            const plotType = document.getElementById(`plot-type-${plotId}`).value;
            const dynamicControlsDiv = document.getElementById(`dynamic-controls-${plotId}`);

            const columns = Object.keys(data[0]).filter(col => !col.startsWith('_'));
            const numericalColumns = columns.filter(col => data.some(row => isNumeric(row[col])));
            const categoricalColumns = columns.filter(col => !numericalColumns.includes(col));

            const cols_for_colorby = columns.filter(col => col !== 'Experiment ID');
            const cols_for_groupby = categoricalColumns.filter(col => col !== 'Experiment ID' && col !== 'BioSample accession');

            let controlsHTML = '';

            if (plotType === 'scatter') {
                controlsHTML += `
                    <div class="row">
                        <!-- X-Axis Control -->
                        <div class="col-md-3">
                            <label for="x-axis-${plotId}">X-Axis:</label>
                            <div class="input-group">
                                <select id="x-axis-${plotId}" class="form-control">
                                    <option value="">Select X-Axis</option>
                                    ${numericalColumns.map(col => `<option value="${col}">${col}</option>`).join('')}
                                </select>
                                <div class="input-group-append">
                                    <div class="input-group-text">
                                        <input type="checkbox" id="x-log-scale-${plotId}">
                                        <label for="x-log-scale-${plotId}" class="mb-0 ml-1">Log</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Y-Axis Control -->
                        <div class="col-md-3">
                            <label for="y-axis-${plotId}">Y-Axis:</label>
                            <div class="input-group">
                                <select id="y-axis-${plotId}" class="form-control">
                                    <option value="">Select Y-Axis</option>
                                    ${numericalColumns.map(col => `<option value="${col}">${col}</option>`).join('')}
                                </select>
                                <div class="input-group-append">
                                    <div class="input-group-text">
                                        <input type="checkbox" id="y-log-scale-${plotId}">
                                        <label for="y-log-scale-${plotId}" class="mb-0 ml-1">Log</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Color By Control -->
                        <div class="col-md-3">
                            <label for="hue-${plotId}">Color By:</label>
                            <select id="hue-${plotId}" class="form-control">
                                <option value="">Select Color</option>
                                ${cols_for_colorby.map(col => `<option value="${col}">${col}</option>`).join('')}
                            </select>
                        </div>
                        <!-- Color Palette Selection -->
                        <div class="col-md-3">
                            <label for="palette-${plotId}">Color Palette:</label>
                            <select id="palette-${plotId}" class="form-control">
                                <option value="Spectral">Spectral</option>
                                <option value="Viridis">Viridis</option>
                                <option value="Cividis">Cividis</option>
                                <option value="Hot">Hot</option>
                                <option value="Jet">Jet</option>
                                <option value="Rainbow">Rainbow</option>
                                <option value="Bluered">Bluered</option>
                            </select>
                        </div>
                    </div>
                    <!-- SRA Assay Type -->
                    <div class="row mt-2 align-items-center">
                        <label class="col-auto mb-0">Assay type:</label>
                        <div id="assay-type-checkboxes-${plotId}" class="col form-inline">
                            ${[...new Set(data.map(row => row["Assay type"]).filter(type => type))].map((type, index) => `
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input" type="checkbox" id="assay-type-${plotId}-${index}" name="assay-type-${plotId}" value="${type}" checked>
                                    <label class="form-check-label" for="assay-type-${plotId}-${index}">
                                        ${type}
                                    </label>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <!-- Range Sliders with Input Boxes in Compact Layout -->
                    <div class="container-fluid">
                        <!-- X-Axis Range Slider -->
                        <div class="row mt-3 p-3 border rounded" style="background-color: #f9f9f9;">
                            <div class="col-2 d-flex align-items-center">
                                <label for="x-range-slider-${plotId}" class="mb-0">X-Axis Range:</label>
                            </div>
                            <div class="col-2">
                                <input type="number" id="x-range-min-input-${plotId}" class="form-control" placeholder="Min">
                            </div>
                            <div class="col-6">
                                <div id="x-range-slider-${plotId}" class="range-slider"></div>
                            </div>
                            <div class="col-2">
                                <input type="number" id="x-range-max-input-${plotId}" class="form-control" placeholder="Max">
                            </div>
                        </div>
                        <!-- Y-Axis Range Slider -->
                        <div class="row mt-3 p-3 border rounded" style="background-color: #f9f9f9;">
                            <div class="col-2 d-flex align-items-center">
                                <label for="y-range-slider-${plotId}" class="mb-0">Y-Axis Range:</label>
                            </div>
                            <div class="col-2">
                                <input type="number" id="y-range-min-input-${plotId}" class="form-control" placeholder="Min">
                            </div>
                            <div class="col-6">
                                <div id="y-range-slider-${plotId}" class="range-slider"></div>
                            </div>
                            <div class="col-2">
                                <input type="number" id="y-range-max-input-${plotId}" class="form-control" placeholder="Max">
                            </div>
                        </div>
                        <!-- Hue Range Slider -->
                        <div id="hue-range-slider-container-${plotId}" class="row mt-3 p-3 border rounded" style="background-color: #f9f9f9; display: none;">
                            <div class="col-2 d-flex align-items-center">
                                <label for="hue-range-slider-${plotId}" class="mb-0">Color Range:</label>
                            </div>
                            <div class="col-2">
                                <input type="number" id="hue-range-min-input-${plotId}" class="form-control" placeholder="Min">
                            </div>
                            <div class="col-6">
                                <div id="hue-range-slider-${plotId}" class="range-slider"></div>
                            </div>
                            <div class="col-2">
                                <input type="number" id="hue-range-max-input-${plotId}" class="form-control" placeholder="Max">
                            </div>
                        </div>
                    </div>
                `;

            } else if (plotType === 'histogram' || plotType === 'boxplot') {
                controlsHTML = `
                    <div class="row">
                        <!-- Numerical Columns -->
                        <div class="col-md-6">
                            <label>Select Numerical Columns:</label>
                            <div id="checkbox-group-${plotId}" class="form-group" style="height: 150px; overflow-y: auto;">
                                ${numericalColumns.map((col, index) => `
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="num-column-${col}-${plotId}" name="num-columns-${plotId}" value="${col}">
                                        <label class="form-check-label" for="num-column-${col}-${plotId}">
                                            ${col}
                                        </label>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <!-- Group By Control -->
                        <div class="col-md-3">
                            <label for="group-by-${plotId}">Group By (Optional):</label>
                            <select id="group-by-${plotId}" class="form-control">
                                <option value="">No Grouping</option>
                                ${cols_for_groupby.map(col => `<option value="${col}">${col}</option>`).join('')}
                            </select>
                        </div>
                        <!-- SRA Assay Type -->
                        <div class="col-md-3 align-items-center">
                            <label class="mb-0">Assay type:</label>
                            <div id="assay-type-checkboxes-${plotId}" class="form-inline">
                                ${[...new Set(data.map(row => row["Assay type"]).filter(type => type))].map((type, index) => `
                                    <div class="form-check form-check-inline">
                                        <input class="form-check-input" type="checkbox" id="assay-type-${plotId}-${index}" name="assay-type-${plotId}" value="${type}" checked>
                                        <label class="form-check-label" for="assay-type-${plotId}-${index}">
                                            ${type}
                                        </label>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            dynamicControlsDiv.innerHTML = controlsHTML;

            // Attach event listeners to new controls
            const controls = dynamicControlsDiv.querySelectorAll('select, input[type=checkbox]');
            controls.forEach(control => {
                control.addEventListener('change', () => updatePlot(plotId));
            });

            // Update plot title display
            const titleInput = document.getElementById(`title-${plotId}`);
            const plotTitleDisplay = document.getElementById(`plot-title-display-${plotId}`);
            titleInput.addEventListener('input', () => {
                plotTitleDisplay.textContent = titleInput.value || `Plot ${plotId.split('-')[1]}`;
            });

            // Initialize sliders when xAxis and yAxis change
            const xAxisSelect = document.getElementById(`x-axis-${plotId}`);
            const yAxisSelect = document.getElementById(`y-axis-${plotId}`);
            const hueSelect = document.getElementById(`hue-${plotId}`);

            if (xAxisSelect) {
                xAxisSelect.addEventListener('change', () => {
                    initializeXAxisSlider(plotId);
                    updatePlot(plotId);
                });
            }

            if (yAxisSelect) {
                yAxisSelect.addEventListener('change', () => {
                    initializeYAxisSlider(plotId);
                    updatePlot(plotId);
                });
            }

            if (hueSelect) {
                hueSelect.addEventListener('change', () => {
                    initializeHueSlider(plotId);
                    updatePlot(plotId);
                });
            }

            // Set control values based on config
            if (config) {
                if (plotType === 'scatter') {
                    if (config.xAxis) xAxisSelect.value = config.xAxis;
                    if (config.yAxis) yAxisSelect.value = config.yAxis;
                    if (config.xLogScale !== undefined) document.getElementById(`x-log-scale-${plotId}`).checked = config.xLogScale;
                    if (config.yLogScale !== undefined) document.getElementById(`y-log-scale-${plotId}`).checked = config.yLogScale;
                    if (config.hue) hueSelect.value = config.hue;
                    if (config.palette) document.getElementById(`palette-${plotId}`).value = config.palette;

                    // Assay types
                    if (config.assayTypes) {
                        config.assayTypes.forEach(assayType => {
                            const checkbox = document.querySelector(`#assay-type-checkboxes-${plotId} input[value="${assayType.value}"]`);
                            if (checkbox) {
                                checkbox.checked = assayType.checked;
                            }
                        });
                    }

                    // Initialize sliders
                    if (config.xAxis) {
                        xAxisSelect.dispatchEvent(new Event('change'));
                        if (config.xRange) {
                            const xSlider = document.getElementById(`x-range-slider-${plotId}`);
                            if (xSlider && xSlider.noUiSlider) {
                                xSlider.noUiSlider.set(config.xRange);
                            }
                        }
                    }

                    if (config.yAxis) {
                        yAxisSelect.dispatchEvent(new Event('change'));
                        if (config.yRange) {
                            const ySlider = document.getElementById(`y-range-slider-${plotId}`);
                            if (ySlider && ySlider.noUiSlider) {
                                ySlider.noUiSlider.set(config.yRange);
                            }
                        }
                    }

                    if (config.hue) {
                        hueSelect.dispatchEvent(new Event('change'));
                        if (config.hueRange) {
                            const hueSlider = document.getElementById(`hue-range-slider-${plotId}`);
                            if (hueSlider && hueSlider.noUiSlider) {
                                hueSlider.noUiSlider.set(config.hueRange);
                            }
                        }
                    }
                } else if (plotType === 'histogram' || plotType === 'boxplot') {
                    // Numerical columns
                    if (config.numColumns) {
                        config.numColumns.forEach(numCol => {
                            const checkbox = document.querySelector(`#checkbox-group-${plotId} input[value="${numCol.value}"]`);
                            if (checkbox) {
                                checkbox.checked = numCol.checked;
                            }
                        });
                    }

                    // Group By
                    if (config.groupBy) {
                        document.getElementById(`group-by-${plotId}`).value = config.groupBy;
                    }

                    // Assay types
                    if (config.assayTypes) {
                        config.assayTypes.forEach(assayType => {
                            const checkbox = document.querySelector(`#assay-type-checkboxes-${plotId} input[value="${assayType.value}"]`);
                            if (checkbox) {
                                checkbox.checked = assayType.checked;
                            }
                        });
                    }
                }
            }

            // Help button event listener
            const helpButton = document.getElementById(`help-button-${plotId}`);
            helpButton.addEventListener('click', function () {
                const helpModal = document.getElementById('help-modal');
                helpModal.style.display = 'flex';
            });

            // Info Button Event Listener
            const infoButton = document.getElementById(`info-plot-${plotId}`);
            infoButton.addEventListener('click', () => {
                showPlotInfo(plotId);
            });


            // Update the plot
            updatePlot(plotId);
        }


        // Function to initialize a slider for a given axis
        function initializeSlider(plotId, axis, axisSliderId, axisMinInputId, axisMaxInputId, axisColumn, callback) {
            const axisValue = document.getElementById(`${axis}-${plotId}`).value;
            const axisSlider = document.getElementById(`${axisSliderId}-${plotId}`);
            const axisMinInput = document.getElementById(`${axisMinInputId}-${plotId}`);
            const axisMaxInput = document.getElementById(`${axisMaxInputId}-${plotId}`);

            if (axisValue && axisSlider) {
                const axisValues = data.map(row => parseFloat(row[axisValue])).filter(val => !isNaN(val));
                const axisMin = Math.min(...axisValues);
                const axisMax = Math.max(...axisValues);

                if (axisSlider.noUiSlider) {
                    axisSlider.noUiSlider.updateOptions({
                        range: {
                            'min': axisMin,
                            'max': axisMax
                        },
                        start: [axisMin, axisMax]
                    });
                } else {
                    noUiSlider.create(axisSlider, {
                        start: [axisMin, axisMax],
                        connect: true,
                        range: {
                            'min': axisMin,
                            'max': axisMax
                        }
                    });

                    axisSlider.noUiSlider.on('update', function (values, handle) {
                        axisMinInput.value = parseFloat(values[0]).toFixed(2);
                        axisMaxInput.value = parseFloat(values[1]).toFixed(2);

                        // Debounce plot update
                        clearTimeout(axisSlider.updateTimeout);
                        axisSlider.updateTimeout = setTimeout(function () {
                            callback(plotId);
                        }, 500);
                    });

                    // Synchronize input boxes with slider
                    axisMinInput.addEventListener('change', function () {
                        axisSlider.noUiSlider.set([this.value, null]);
                    });
                    axisMaxInput.addEventListener('change', function () {
                        axisSlider.noUiSlider.set([null, this.value]);
                    });
                }
            }
        }

        // Wrapper for X-axis slider initialization
        function initializeXAxisSlider(plotId) {
            initializeSlider(plotId, 'x-axis', 'x-range-slider', 'x-range-min-input', 'x-range-max-input', 'xAxis', updatePlot);
        }

        // Wrapper for Y-axis slider initialization
        function initializeYAxisSlider(plotId) {
            initializeSlider(plotId, 'y-axis', 'y-range-slider', 'y-range-min-input', 'y-range-max-input', 'yAxis', updatePlot);
        }

        // Wrapper for Hue slider initialization
        function initializeHueSlider(plotId) {
            const hueColumn = document.getElementById(`hue-${plotId}`).value;
            const hueSliderContainer = document.getElementById(`hue-range-slider-container-${plotId}`);
            const hueSlider = document.getElementById(`hue-range-slider-${plotId}`);
            const hueMinInput = document.getElementById(`hue-range-min-input-${plotId}`);
            const hueMaxInput = document.getElementById(`hue-range-max-input-${plotId}`);

            if (hueColumn && hueSlider) {
                const hueValues = data.map(row => parseFloat(row[hueColumn])).filter(val => !isNaN(val));
                const hueMin = Math.min(...hueValues);
                const hueMax = Math.max(...hueValues);
                const isHueNumeric = data.some(row => isNumeric(row[hueColumn]));

                if (isHueNumeric) {
                    hueSliderContainer.style.display = 'flex';
                    initializeSlider(plotId, 'hue', 'hue-range-slider', 'hue-range-min-input', 'hue-range-max-input', 'hueColumn', updatePlot);
                } else {
                    hueSliderContainer.style.display = 'none';
                    if (hueSlider.noUiSlider) {
                        hueSlider.noUiSlider.destroy();
                    }
                }
            } else {
                hueSliderContainer.style.display = 'none';
                if (hueSlider.noUiSlider) {
                    hueSlider.noUiSlider.destroy();
                }
            }
        }

        function applyFiltersToData(dataSet, filters, plotId) {
            let filteredData = dataSet;

            filters.forEach((filter, index) => {
                const { logic, column, operator, value } = filter;

                const isNumericalFilter = typeof value === 'object' && value.min !== undefined && value.max !== undefined;
                let filterFunction;

                if (isNumericalFilter) {
                    // Numerical filter
                    filterFunction = (row) => {
                        const rowValue = parseFloat(row[column]);
                        return rowValue >= value.min && rowValue <= value.max;
                    };
                    logOperation(plotId, `Applied numerical filter: ${logic} ${column} between ${value.min} and ${value.max}`);
                } else {
                    // Categorical filter
                    if (operator === 'in' && Array.isArray(value)) {
                        filterFunction = (row) => value.includes(row[column]);
                        logOperation(plotId, `Applied numerical filter: ${logic} ${column} between ${value.min} and ${value.max}`);
                    } else if (operator === 'not_in' && Array.isArray(value)) {
                        filterFunction = (row) => !value.includes(row[column]);
                        logOperation(plotId, `Applied numerical filter: ${logic} ${column} between ${value.min} and ${value.max}`);
                    } else {
                        // Unknown operator or missing value
                        filterFunction = () => true;
                    }
                }

                if (index === 0) {
                    // Apply NOT logic if specified in the first filter
                    if (logic === 'NOT') {
                        filteredData = filteredData.filter(row => !filterFunction(row));
                    } else {
                        filteredData = filteredData.filter(filterFunction);
                    }
                } else {
                    if (logic === 'AND') {
                        filteredData = filteredData.filter(filterFunction);
                    } else if (logic === 'OR') {
                        const newData = dataSet.filter(filterFunction);
                        filteredData = [...new Set([...filteredData, ...newData])];
                    } else if (logic === 'NOT') {
                        filteredData = filteredData.filter(row => !filterFunction(row));
                    }
                }
            });

            return filteredData;
        }


        function searchAndSelectPoints(plotId) {
            const searchInput = document.getElementById(`search-input-${plotId}`);
            let searchText = searchInput.value.trim().toLowerCase();

            if (searchText === '') {
                return;
            }

            const matchingPoints = data.filter(row => {
                return ['BioProject', 'BioSample accession', 'Experiment ID', '_uniqueId'].some(col => {
                    return row[col] && row[col].toString().toLowerCase() === searchText;
                });
            });

            if (matchingPoints.length === 0) {
                alert('No matching data points found.');
                operationsLog.push(`Search performed with no matches for: ${searchText}`);
                return;
            }

            matchingPoints.forEach(point => {
                if (!selectedPoints.some(p => p._uniqueId === point._uniqueId)) {
                    selectedPoints.push(point);
                    operationsLog.push(`Selected point via search: ${point._uniqueId}`);
                }
            });

            updateTable();
            highlightSelectedPoints();
        }



        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }


        function updatePlot(plotId) {
            const plotDiv = document.getElementById(plotId);
            if (!plotDiv) {
                return;
            }
            const plotType = document.getElementById(`plot-type-${plotId}`).value;

            const assayTypeCheckboxes = document.querySelectorAll(`#assay-type-checkboxes-${plotId} input[name="assay-type-${plotId}"]:checked`);
            const selectedAssayTypes = Array.from(assayTypeCheckboxes).map(checkbox => checkbox.value);
            let plotDataSet = selectedAssayTypes.length > 0 ? data.filter(row => selectedAssayTypes.includes(row["Assay type"])) : data;

            // Apply filters if any
            if (plotFilters[plotId] && plotFilters[plotId].length > 0) {
                plotDataSet = applyFiltersToData(plotDataSet, plotFilters[plotId], plotId);
            }

            currentPlotData = plotDataSet;

            // Initialize plotViewRanges for this plot if not already initialized
            if (!plotViewRanges[plotId]) {
                plotViewRanges[plotId] = { xMin: null, xMax: null, yMin: null, yMax: null };
            }

            if (plotType === 'scatter') {
                const xAxis = document.getElementById(`x-axis-${plotId}`).value;
                const yAxis = document.getElementById(`y-axis-${plotId}`).value;
                const hueColumn = document.getElementById(`hue-${plotId}`).value;
                const palette = document.getElementById(`palette-${plotId}`).value || 'Spectral';

                // Get the state of the log scale checkboxes
                const xLogScale = document.getElementById(`x-log-scale-${plotId}`).checked;
                const yLogScale = document.getElementById(`y-log-scale-${plotId}`).checked;

                if (!xAxis || !yAxis) {
                    plotDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Please select values for X-Axis and Y-Axis.</p>';
                    return;
                }

                // Apply X and Y range filters
                const xSlider = document.getElementById(`x-range-slider-${plotId}`);
                const ySlider = document.getElementById(`y-range-slider-${plotId}`);

                let xMin = null, xMax = null, yMin = null, yMax = null;

                if (xSlider && xSlider.noUiSlider) {
                    const xRange = xSlider.noUiSlider.get();
                    xMin = parseFloat(xRange[0]);
                    xMax = parseFloat(xRange[1]);
                }

                if (ySlider && ySlider.noUiSlider) {
                    const yRange = ySlider.noUiSlider.get();
                    yMin = parseFloat(yRange[0]);
                    yMax = parseFloat(yRange[1]);
                }

                const isHueNumeric = hueColumn && currentPlotData.some(row => isNumeric(row[hueColumn]));

                // Filter data based on X and Y ranges
                let filteredData = currentPlotData.filter(row => {
                    const xValue = parseFloat(row[xAxis]);
                    const yValue = parseFloat(row[yAxis]);

                    return (
                        !isNaN(xValue) && xValue >= xMin && xValue <= xMax &&
                        !isNaN(yValue) && yValue >= yMin && yValue <= yMax
                    );
                });

                const pointsDisplayed = filteredData.length;
                const pointsSelectedInPlot = filteredData.filter(row => selectedPoints.some(p => p._uniqueId === row._uniqueId)).length;

                // Compute points per assay type
                const assayTypeCounts = {};
                filteredData.forEach(row => {
                    const assayType = row["Assay type"] || "Unknown";
                    assayTypeCounts[assayType] = (assayTypeCounts[assayType] || 0) + 1;
                });

                // Update counts display
                document.getElementById(`points-displayed-${plotId}`).textContent = pointsDisplayed;
                document.getElementById(`points-selected-${plotId}`).textContent = pointsSelectedInPlot;

                const assayTypeCountsArray = Object.entries(assayTypeCounts).map(([assayType, count]) => `${assayType}: ${count}`);
                document.getElementById(`assay-type-counts-${plotId}`).textContent = assayTypeCountsArray.join(', ');

                // Log the filter operation
                logOperation(plotId, `Updated plot ${plotId}: Displayed ${pointsDisplayed} points, Selected ${pointsSelectedInPlot} points.`);



                let traces = [];

                if (isHueNumeric && hueColumn) {
                    // Apply hue range filter
                    const hueSlider = document.getElementById(`hue-range-slider-${plotId}`);
                    let hueMin = null, hueMax = null;
                    if (hueSlider && hueSlider.noUiSlider) {
                        const hueRange = hueSlider.noUiSlider.get();
                        hueMin = parseFloat(hueRange[0]);
                        hueMax = parseFloat(hueRange[1]);
                    } else {
                        // If hue slider is not initialized, set default min and max
                        const hueValues = filteredData.map(row => parseFloat(row[hueColumn])).filter(val => !isNaN(val));
                        hueMin = Math.min(...hueValues);
                        hueMax = Math.max(...hueValues);
                    }

                    // Create arrays for in-range and out-of-range points
                    const inRangeData = {
                        x: [],
                        y: [],
                        text: [],
                        ids: [],
                        hue: []
                    };
                    const outOfRangeData = {
                        x: [],
                        y: [],
                        text: [],
                        ids: [],
                        hue: []
                    };

                    filteredData.forEach(row => {
                        const hueValue = parseFloat(row[hueColumn]);
                        const xValue = parseFloat(row[xAxis]);
                        const yValue = parseFloat(row[yAxis]);

                        if (hueValue >= hueMin && hueValue <= hueMax) {
                            inRangeData.x.push(xValue);
                            inRangeData.y.push(yValue);
                            inRangeData.text.push(
                                `X (${xAxis}): ${xValue}<br>Y (${yAxis}): ${yValue}<br>` +
                                hoverColumns.map(col => `${col}: ${row[col]}`).join('<br>')
                            );
                            inRangeData.ids.push(row._uniqueId);
                            inRangeData.hue.push(hueValue);
                        } else {
                            outOfRangeData.x.push(xValue);
                            outOfRangeData.y.push(yValue);
                            outOfRangeData.text.push(
                                `X (${xAxis}): ${xValue}<br>Y (${yAxis}): ${yValue}<br>` +
                                hoverColumns.map(col => `${col}: ${row[col]}`).join('<br>')
                            );
                            outOfRangeData.ids.push(row._uniqueId);
                            outOfRangeData.hue.push(hueValue);
                        }
                    });

                    // Trace for points within hue range
                    const traceInRange = {
                        x: inRangeData.x,
                        y: inRangeData.y,
                        text: inRangeData.text,
                        customdata: inRangeData.ids,
                        ids: inRangeData.ids,
                        mode: 'markers',
                        type: 'scatter',
                        marker: {
                            color: inRangeData.hue,
                            colorscale: palette,
                            colorbar: { title: hueColumn, titleside: 'right' },
                            cmin: hueMin,
                            cmax: hueMax,
                            size: 6,
                            opacity: 1
                        },
                        showlegend: false,
                        hoverinfo: 'text',
                        selected: {
                            marker: {
                                color: 'black',
                                size: 12,
                            }
                        }
                    };

                    // Trace for points outside hue range (faded)
                    const traceOutOfRange = {
                        x: outOfRangeData.x,
                        y: outOfRangeData.y,
                        text: outOfRangeData.text,
                        customdata: outOfRangeData.ids,
                        ids: outOfRangeData.ids,
                        mode: 'markers',
                        type: 'scatter',
                        marker: {
                            color: outOfRangeData.hue,
                            colorscale: palette,
                            cmin: hueMin,
                            cmax: hueMax,
                            size: 4,
                            opacity: 0.2,
                            showscale: false,
                        },
                        showlegend: false,
                        hoverinfo: 'text',
                        selected: {
                            marker: {
                                color: 'black',
                                size: 12,
                            }
                        }
                    };

                    traces = [traceInRange, traceOutOfRange];
                } else {
                    // For categorical hue or no hue
                    const categories = hueColumn ? [...new Set(filteredData.map(row => row[hueColumn]))] : ['Data'];

                    traces = categories.map(category => {
                        const categoryData = hueColumn ? filteredData.filter(row => row[hueColumn] === category) : filteredData;

                        return {
                            x: categoryData.map(row => parseFloat(row[xAxis])),
                            y: categoryData.map(row => parseFloat(row[yAxis])),
                            text: categoryData.map(row =>
                                hoverColumns.map(col => `${col}: ${row[col]}`).join('<br>')
                            ),
                            customdata: categoryData.map(row => row._uniqueId),
                            ids: categoryData.map(row => row._uniqueId),
                            mode: 'markers',
                            type: 'scatter',
                            name: category,
                            marker: {
                                size: 6,
                            },
                            hoverinfo: 'text',
                            selected: {
                                marker: {
                                    color: 'black',
                                    size: 12
                                }
                            }
                        };
                    });
                }

                const layout = {
                    xaxis: { title: xAxis, type: xLogScale ? 'log' : 'linear' },
                    yaxis: { title: yAxis, type: yLogScale ? 'log' : 'linear' },
                    hovermode: 'closest',
                    showlegend: true,
                    margin: { t: 50 },
                    plot_bgcolor: '#f8f9fa',
                    paper_bgcolor: '#f8f9fa'
                };

                Plotly.newPlot(plotDiv, traces, layout).then(() => {
                    plotDiv.on('plotly_click', (eventData) => onPointClick(eventData, plotId));
                    highlightSelectedPoints();

                    // Attach Plotly Event Listeners for Real-Time Updates
                    plotDiv.on('plotly_relayout', function (eventdata) {
                        // When the plot is zoomed or panned, update the summary
                        updateCountsDisplay(plotId);
                    });

                    plotDiv.on('plotly_selected', function (eventData) {
                        // When points are selected via Plotly's lasso or box select
                        handlePlotlySelection(eventData, plotId);
                        updateCountsDisplay(plotId);
                    });

                    plotDiv.on('plotly_deselect', function (eventData) {
                        // When points are deselected
                        handlePlotlyDeselection(eventData, plotId);
                        updateCountsDisplay(plotId);
                    });

                    plotDiv.on('plotly_restyle', function (eventData) {
                        updateCountsDisplay(plotId);
                    });


                    // Initial counts update
                    updateCountsDisplay(plotId);


                });

            } else if (plotType === 'boxplot') {
                // Updated retrieval of selected numerical columns
                const numColumns = Array.from(document.querySelectorAll(`#checkbox-group-${plotId} input[name="num-columns-${plotId}"]:checked`)).map(checkbox => checkbox.value);
                const groupBy = document.getElementById(`group-by-${plotId}`).value;

                if (numColumns.length === 0) {
                    plotDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Please select at least one numerical column to generate the boxplot.</p>';
                    return;
                }

                let traces = [];

                numColumns.forEach(numCol => {
                    if (groupBy) {
                        const categories = [...new Set(currentPlotData.map(row => row[groupBy]))];

                        categories.forEach(category => {
                            const filteredData = currentPlotData.filter(row => row[groupBy] === category);

                            traces.push({
                                y: filteredData.map(row => parseFloat(row[numCol])),
                                type: 'box',
                                name: `${numCol} - ${category}`,
                                boxpoints: 'outliers',
                                hoverinfo: 'y',
                            });
                        });
                    } else {
                        traces.push({
                            y: currentPlotData.map(row => parseFloat(row[numCol])),
                            type: 'box',
                            name: numCol,
                            boxpoints: 'outliers',
                            hoverinfo: 'y',
                        });
                    }
                });

                const layout = {
                    yaxis: { title: 'Value' },
                    xaxis: { title: 'Variables' },
                    margin: { t: 50 },
                    plot_bgcolor: '#f8f9fa',
                    paper_bgcolor: '#f8f9fa'
                };

                Plotly.newPlot(plotDiv, traces, layout);

            } else if (plotType === 'histogram') {
                // Updated retrieval of selected numerical columns
                const numColumns = Array.from(document.querySelectorAll(`#checkbox-group-${plotId} input[name="num-columns-${plotId}"]:checked`)).map(checkbox => checkbox.value);
                const groupBy = document.getElementById(`group-by-${plotId}`).value;

                if (numColumns.length === 0) {
                    plotDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Please select at least one numerical column to generate the histogram.</p>';
                    return;
                }

                let traces = [];

                numColumns.forEach(numCol => {
                    if (groupBy) {
                        const categories = [...new Set(currentPlotData.map(row => row[groupBy]))];

                        categories.forEach(category => {
                            const filteredData = currentPlotData.filter(row => row[groupBy] === category);
                            traces.push({
                                x: filteredData.map(row => parseFloat(row[numCol])),
                                type: 'histogram',
                                name: `${numCol} - ${category}`,
                                opacity: 0.75,
                                marker: { opacity: 0.75 },
                                hoverinfo: 'x+y',
                            });
                        });
                    } else {
                        traces.push({
                            x: currentPlotData.map(row => parseFloat(row[numCol])),
                            type: 'histogram',
                            name: numCol,
                            opacity: 0.75,
                            marker: { opacity: 0.75 },
                            hoverinfo: 'x+y',
                        });
                    }
                });

                const layout = {
                    xaxis: { title: 'Value' },
                    yaxis: { title: 'Count' },
                    barmode: groupBy ? 'group' : 'overlay',
                    margin: { t: 50 },
                    plot_bgcolor: '#f8f9fa',
                    paper_bgcolor: '#f8f9fa',
                    // bar width
                    bargap: 0.1,
                };

                Plotly.newPlot(plotDiv, traces, layout);

            }
            else {
                plotDiv.innerHTML = '<p style="text-align: center; color: #e74c3c;">Invalid plot type selected.</p>';
            }
            updateCountsDisplay(plotId);
        }

        function onPointClick(eventData, plotId) {
            const pt = eventData.points[0];
            const clickedId = pt.customdata;

            const clickedPoint = data.find(row => row._uniqueId === clickedId);

            if (!clickedPoint) return;

            const index = selectedPoints.findIndex(p => p._uniqueId === clickedId);

            if (index === -1) {
                selectedPoints.push(clickedPoint);
                logOperation(plotId, `Selected point: ${clickedId}`);
            } else {
                selectedPoints.splice(index, 1);
                logOperation(plotId, `Selected point: ${clickedId}`);
            }
            updateTable();
            highlightSelectedPoints();
        }

        function highlightSelectedPoints() {
            const selectedIds = new Set(selectedPoints.map(p => p._uniqueId));

            // Use requestAnimationFrame for better performance
            requestAnimationFrame(() => {
                for (let i = 1; i <= plotCounter; i++) {
                    const plotId = `plot-${i}`;
                    const plotDiv = document.getElementById(plotId);
                    if (plotDiv && plotDiv.data) {
                        const update = {
                            selectedpoints: [],
                            selected: {
                                marker: {
                                    zorder: 99999999,
                                    size: 8,
                                    symbol: 'circle',
                                    color: 'black',
                                    opacity: 1,
                                    line: {
                                        color: 'red',
                                        width: 1,
                                    }
                                },
                            },
                            unselected: {
                                marker: {
                                    zorder: 1,
                                    opacity: 0.9,
                                }
                            }
                        };
                        updateCountsDisplay(plotId);

                        plotDiv.data.forEach((trace) => {
                            const selectedIndices = [];
                            if (trace.ids) {
                                trace.ids.forEach((id, index) => {
                                    if (selectedIds.has(id)) {
                                        selectedIndices.push(index);
                                    }
                                });
                                update.selectedpoints.push(selectedIndices);
                            } else {
                                update.selectedpoints.push(null);
                            }
                        });
                        Plotly.restyle(plotDiv, update);
                    }
                }
            });
        }


        function updateTable() {
            const columns = data && data.length > 0 ? Object.keys(data[0]).filter(col => !col.startsWith('_')) : [];

            // Start building the table with the Actions column first
            let tableHTML = '<table class="table table-striped table-bordered"><thead><tr>';
            tableHTML += `<th>Actions</th>`; // Actions column as the first column
            columns.forEach(col => {
                tableHTML += `<th>${col}</th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            if (selectedPoints.length === 0) {
                tableHTML += `<tr><td colspan="${columns.length + 1}" style="text-align: center;">No points selected. Click on points in the plot to add them to the table.</td></tr>`;
            } else {
                selectedPoints.forEach(point => {
                    tableHTML += '<tr>';

                    // Actions Dropdown in the first cell
                    tableHTML += `
                        <td>
                            <div class="dropdown">
                                <button class="btn btn-sm btn-secondary dropdown-toggle" type="button" id="dropdownMenuButton-${point._uniqueId}" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                    Actions
                                </button>
                                <div class="dropdown-menu" aria-labelledby="dropdownMenuButton-${point._uniqueId}">
                                    <a class="dropdown-item view-sra" href="#" data-unique-id="${point._uniqueId}">View in SRA</a>
                                    <a class="dropdown-item show-depth" href="#" data-unique-id="${point._uniqueId}">Show depth per chromosome</a>
                                    <a class="dropdown-item purge-experiment" href="#" data-unique-id="${point._uniqueId}">Purge Experiment</a>
                                    <a class="dropdown-item purge-bioproject" href="#" data-bioproject="${point['BioProject']}">Purge BioProject</a>
                                    <a class="dropdown-item purge-biosample" href="#" data-biosample="${point['BioSample']}">Purge BioSample</a>
                                </div>
                            </div>
                        </td>
                    `;

                    // Add the rest of the columns
                    columns.forEach(col => {
                        tableHTML += `<td>${point[col]}</td>`;
                    });
                    tableHTML += '</tr>';
                });
            }

            tableHTML += '</tbody></table>';
            tableContainer.innerHTML = tableHTML;
        }


        function clearSelections() {
            selectedPoints = [];
            updateTable();
            highlightSelectedPoints();
            showNotification('Selections cleared.');
        }


        function exportAllDataAsPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('portrait', 'pt', 'a4');
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();

            // Add Company Logo (Replace 'logo.png' with your logo file path)
            const logoImg = new Image();
            logoImg.src = 'https://avatars.githubusercontent.com/u/163611200?s=400&u=d20c621ec8b0ebe1bb072c19b26726e95712d971&v=4'; // Ensure the logo is accessible
            logoImg.onload = () => {
                doc.addImage(logoImg, 'PNG', 40, 40, 100, 50);

                // Cover Page
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(24);
                doc.text("Snipe Explore Report", pageWidth / 2, 120, null, null, 'center');

                // Date and Time
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(12);
                doc.text(`Export Date: ${new Date().toLocaleString()}`, pageWidth / 2, 140, null, null, 'center');

                // Move to next page for TOC
                doc.addPage();

                // Table of Contents
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(18);
                doc.text("Table of Contents", 40, 80);

                let tocYPosition = 110;
                const plotPageNumbers = [];

                // Collect promises for images and build TOC
                const promises = [];
                for (let i = 1; i <= plotCounter; i++) {
                    const plotId = `plot-${i}`;
                    const plotDiv = document.getElementById(plotId);
                    const plotTitleInput = document.getElementById(`title-${plotId}`);
                    const plotTitle = plotTitleInput && plotTitleInput.value.trim() !== '' ? plotTitleInput.value : `Plot ${i}`;
                    const pageNum = doc.internal.getNumberOfPages() + promises.length + 1;
                    plotPageNumbers.push(pageNum);

                    // Add entry to TOC
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(12);
                    doc.text(plotTitle, 60, tocYPosition);
                    doc.text(`Page ${pageNum}`, pageWidth - 60, tocYPosition, null, null, 'right');
                    tocYPosition += 20;

                    if (tocYPosition > pageHeight - 80) {
                        doc.addPage();
                        tocYPosition = 80;
                    }

                    if (plotDiv) {
                        const promise = Plotly.toImage(plotDiv, { format: 'png', width: 1200, height: 800 })
                            .then(function (dataUrl) {
                                // Add a new page for the plot
                                doc.addPage();

                                // Add plot title
                                doc.setFont('helvetica', 'bold');
                                doc.setFontSize(16);
                                doc.text(plotTitle, pageWidth / 2, 50, null, null, 'center');

                                // Add plot image
                                const imgWidth = pageWidth - 80;
                                const imgHeight = (imgWidth * 800) / 1200; // Maintain aspect ratio
                                doc.addImage(dataUrl, 'PNG', 40, 70, imgWidth, imgHeight);

                                // Add plot details
                                doc.setFont('helvetica', 'normal');
                                doc.setFontSize(12);
                                const plotType = document.getElementById(`plot-type-${plotId}`).value;
                                let detailsYPosition = 80 + imgHeight + 20;

                                // Add plot type
                                doc.text(`Plot Type: ${plotType}`, 60, detailsYPosition);

                                if (plotType === 'scatter') {
                                    const xAxisValue = document.getElementById(`x-axis-${plotId}`).value;
                                    const yAxisValue = document.getElementById(`y-axis-${plotId}`).value;
                                    const hueValue = document.getElementById(`hue-${plotId}`).value;
                                    const xLogScale = document.getElementById(`x-log-scale-${plotId}`).checked ? 'Yes' : 'No';
                                    const yLogScale = document.getElementById(`y-log-scale-${plotId}`).checked ? 'Yes' : 'No';

                                    doc.text(`X-Axis: ${xAxisValue} (Log Scale: ${xLogScale})`, 60, detailsYPosition + 20);
                                    doc.text(`Y-Axis: ${yAxisValue} (Log Scale: ${yLogScale})`, 60, detailsYPosition + 40);
                                    doc.text(`Color By: ${hueValue}`, 60, detailsYPosition + 60);
                                }
                                else if (plotType === 'histogram' || plotType === 'boxplot') {
                                    // Updated retrieval of selected numerical columns
                                    const numColumns = Array.from(document.querySelectorAll(`#checkbox-group-${plotId} input[name="num-columns-${plotId}"]:checked`)).map(checkbox => checkbox.value).join(', ');
                                    const groupBy = document.getElementById(`group-by-${plotId}`).value || 'None';
                                    doc.text(`Numerical Columns: ${numColumns}`, 60, detailsYPosition + 20);
                                    doc.text(`Group By: ${groupBy}`, 60, detailsYPosition + 40);
                                }

                                const assayTypeCheckboxes = document.querySelectorAll(`#assay-type-checkboxes-${plotId} input[name="assay-type-${plotId}"]:checked`);
                                const selectedAssayTypes = Array.from(assayTypeCheckboxes).map(checkbox => checkbox.value);
                                const assayTypeValue = Array.from(assayTypeCheckboxes).map(checkbox => checkbox.value).join(', ') || 'All';

                                currentPlotData = data.filter(row => {
                                    const assayType = row["Assay type"] || 'Unknown';
                                    return selectedAssayTypes.includes(assayType);
                                });

                                doc.text(`Assay type: ${assayTypeValue}`, 60, detailsYPosition + 80);

                                // Add user's notes
                                const notesValue = document.getElementById(`notes-${plotId}`).value;
                                if (notesValue.trim() !== '') {
                                    doc.setFont('helvetica', 'bolditalic');
                                    doc.text("Notes:", 60, detailsYPosition + 90);
                                    doc.setFont('helvetica', 'normal');
                                    // Handle multi-line notes
                                    const lines = doc.splitTextToSize(notesValue, pageWidth - 120);
                                    doc.text(lines, 60, detailsYPosition + 110);
                                }
                            });
                        promises.push(promise);
                    }
                }

                Promise.all(promises).then(() => {
                    doc.addPage();

                    // Data Statistics
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(16);
                    doc.text("Data Statistics", 40, 80);

                    // Example: Display total points displayed and selected
                    let statsYPosition = 110;
                    const totalPointsDisplayed = data.length;
                    const totalPointsSelected = selectedPoints.length;

                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(12);
                    doc.text(`Total Points in Dataset: ${totalPointsDisplayed}`, 60, statsYPosition);
                    statsYPosition += 20;
                    doc.text(`Total Points Selected: ${totalPointsSelected}`, 60, statsYPosition);
                    statsYPosition += 20;

                    // Points per assay type
                    const assayTypeCounts = {};
                    data.forEach(row => {
                        const assayType = row["Assay type"] || "Unknown";
                        assayTypeCounts[assayType] = (assayTypeCounts[assayType] || 0) + 1;
                    });
                    const assayTypeCountsArray = Object.entries(assayTypeCounts).map(([assayType, count]) => `${assayType}: ${count}`);

                    doc.text(`Points per Assay Type:`, 60, statsYPosition);
                    statsYPosition += 20;
                    assayTypeCountsArray.forEach(line => {
                        doc.text(`- ${line}`, 80, statsYPosition);
                        statsYPosition += 20;
                    });

                    // Operations Log
                    doc.addPage();
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(16);
                    doc.text("Operations Log", 40, 80);

                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(12);

                    let logYPosition = 110;
                    operationsLog.forEach((logEntry, index) => {
                        const logText = `${index + 1}. ${logEntry}`;
                        const lines = doc.splitTextToSize(logText, pageWidth - 80);
                        doc.text(lines, 60, logYPosition);
                        logYPosition += lines.length * 14 + 10;
                        if (logYPosition > pageHeight - 80) {
                            doc.addPage();
                            logYPosition = 80;
                        }
                    });


                    // Add page numbers
                    const pageCount = doc.internal.getNumberOfPages();
                    for (let i = 1; i <= pageCount; i++) {
                        doc.setPage(i);
                        doc.setFontSize(10);
                        doc.text(`Page ${i} of ${pageCount}`, pageWidth / 2, pageHeight - 30, null, null, 'center');
                    }

                    // Save the PDF
                    doc.save("snipe_visualization_report.pdf");
                });
            };
        }


        function collectSessionData() {
            const sessionData = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    dataFilePath: dataFilePath,
                },
                selectedSpecies: document.getElementById('species-select').value,
                selectedReference: document.getElementById('reference-select').value,
                selectedAmplicon: document.getElementById('amplicon-select').value,
                plots: [],
                selectedPoints: selectedPoints.map(p => p._uniqueId),
            };

            // Collect data for each plot
            for (let i = 1; i <= plotCounter; i++) {
                const plotId = `plot-${i}`;
                const plotType = document.getElementById(`plot-type-${plotId}`).value;
                const plotConfig = {
                    plotId: plotId,
                    plotType: plotType,
                    controls: {},
                    title: document.getElementById(`title-${plotId}`).value,
                    notes: document.getElementById(`notes-${plotId}`).value,
                    filters: plotFilters[plotId] ? plotFilters[plotId] : []
                };

                // Collect control values based on plot type
                if (plotType === 'scatter') {
                    plotConfig.controls.xAxis = document.getElementById(`x-axis-${plotId}`).value;
                    plotConfig.controls.yAxis = document.getElementById(`y-axis-${plotId}`).value;
                    plotConfig.controls.hue = document.getElementById(`hue-${plotId}`).value;
                    plotConfig.controls.xLogScale = document.getElementById(`x-log-scale-${plotId}`).checked;
                    plotConfig.controls.yLogScale = document.getElementById(`y-log-scale-${plotId}`).checked;
                    plotConfig.controls.palette = document.getElementById(`palette-${plotId}`).value;

                    // Save range slider values (using correct IDs)
                    const xSlider = document.getElementById(`x-range-slider-${plotId}`);
                    const ySlider = document.getElementById(`y-range-slider-${plotId}`);
                    const hueSlider = document.getElementById(`hue-range-slider-${plotId}`);

                    if (xSlider && xSlider.noUiSlider) {
                        const [xMin, xMax] = xSlider.noUiSlider.get().map(Number);
                        plotConfig.controls.xRange = { min: xMin, max: xMax };
                    }
                    if (ySlider && ySlider.noUiSlider) {
                        const [yMin, yMax] = ySlider.noUiSlider.get().map(Number);
                        plotConfig.controls.yRange = { min: yMin, max: yMax };
                    }
                    if (hueSlider && hueSlider.noUiSlider) {
                        const [hueMin, hueMax] = hueSlider.noUiSlider.get().map(Number);
                        plotConfig.controls.hueRange = { min: hueMin, max: hueMax };
                    }
                } else if (plotType === 'histogram' || plotType === 'boxplot') {
                    plotConfig.controls.numColumns = Array.from(
                        document.querySelectorAll(
                            `#checkbox-group-${plotId} input[name="num-columns-${plotId}"]:checked`
                        )
                    ).map(checkbox => checkbox.value);
                    plotConfig.controls.groupBy = document.getElementById(`group-by-${plotId}`).value;
                }

                // Collect selected assay types
                plotConfig.controls.selectedAssayTypes = Array.from(
                    document.querySelectorAll(
                        `#assay-type-checkboxes-${plotId} input[name="assay-type-${plotId}"]:checked`
                    )
                ).map(checkbox => checkbox.value);

                // Collect filters
                plotConfig.filters = plotFilters[plotId] ? plotFilters[plotId] : [];

                sessionData.plots.push(plotConfig);
            }

            // Include user data if present
            const userDataPoints = data.filter(row => row._isUserData);
            if (userDataPoints.length > 0) {
                sessionData.userData = userDataPoints.map(row => {
                    const newRow = {};
                    for (let key in row) {
                        if (!key.startsWith('_')) {
                            newRow[key] = row[key];
                        }
                    }
                    return newRow;
                });
            }

            return sessionData;
        }


        function exportSession() {
            const sessionData = collectSessionData();

            // Convert session data to JSON string
            const jsonData = JSON.stringify(sessionData, null, 2);

            // Create a blob and trigger download
            const blob = new Blob([jsonData], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'session_data.json';
            link.click();

            // Show notification
            showNotification('Session exported successfully.');
        }

        function importSession(jsonData, userData = null) {
            try {
                // Show loading modal
                document.getElementById('loading-modal').style.display = 'flex';

                const sessionData = JSON.parse(jsonData);

                // Clear existing data and plots
                clearAllData();
                plotsContainer.innerHTML = '';
                plotCounter = 0;
                selectedPoints = [];
                plotFilters = {};

                // Restore species, reference, and amplicon selections
                document.getElementById('species-select').value = sessionData.selectedSpecies;
                document.getElementById('species-select').dispatchEvent(new Event('change'));

                document.getElementById('reference-select').value = sessionData.selectedReference;
                document.getElementById('reference-select').dispatchEvent(new Event('change'));

                document.getElementById('amplicon-select').value = sessionData.selectedAmplicon;
                document.getElementById('amplicon-select').dispatchEvent(new Event('change'));

                // Load data file
                const filePath = sessionData.metadata.dataFilePath;
                loadData(filePath, () => {
                    // After data is loaded, integrate session userData if present
                    if (sessionData.userData) {
                        integrateUserData(sessionData.userData);
                    }

                    // Integrate user data from URL if present
                    if (userData) {
                        integrateUserData(userData);
                    }

                    // Restore plots
                    sessionData.plots.forEach(plotConfig => {
                        addNewPlot();

                        // Restore plot type
                        document.getElementById(`plot-type-${plotConfig.plotId}`).value = plotConfig.plotType;
                        renderDynamicControls(plotConfig.plotId, plotConfig);

                        // Restore controls
                        if (plotConfig.plotType === 'scatter') {
                            document.getElementById(`x-axis-${plotConfig.plotId}`).value = plotConfig.controls.xAxis;
                            document.getElementById(`y-axis-${plotConfig.plotId}`).value = plotConfig.controls.yAxis;
                            document.getElementById(`hue-${plotConfig.plotId}`).value = plotConfig.controls.hue;
                            document.getElementById(`x-log-scale-${plotConfig.plotId}`).checked = plotConfig.controls.xLogScale;
                            document.getElementById(`y-log-scale-${plotConfig.plotId}`).checked = plotConfig.controls.yLogScale;
                            document.getElementById(`palette-${plotConfig.plotId}`).value = plotConfig.controls.palette || 'Spectral';

                            // Initialize sliders
                            initializeXAxisSlider(plotConfig.plotId);
                            initializeYAxisSlider(plotConfig.plotId);
                            initializeHueSlider(plotConfig.plotId);

                            // Restore slider positions
                            const xSlider = document.getElementById(`x-range-slider-${plotConfig.plotId}`);
                            const ySlider = document.getElementById(`y-range-slider-${plotConfig.plotId}`);
                            const hueSlider = document.getElementById(`hue-range-slider-${plotConfig.plotId}`);

                            if (xSlider && xSlider.noUiSlider && plotConfig.controls.xRange) {
                                xSlider.noUiSlider.set([plotConfig.controls.xRange.min, plotConfig.controls.xRange.max]);
                            }
                            if (ySlider && ySlider.noUiSlider && plotConfig.controls.yRange) {
                                ySlider.noUiSlider.set([plotConfig.controls.yRange.min, plotConfig.controls.yRange.max]);
                            }
                            if (hueSlider && hueSlider.noUiSlider && plotConfig.controls.hueRange) {
                                hueSlider.noUiSlider.set([plotConfig.controls.hueRange.min, plotConfig.controls.hueRange.max]);
                            }
                        } else if (plotConfig.plotType === 'histogram' || plotConfig.plotType === 'boxplot') {
                            plotConfig.controls.numColumns.forEach(col => {
                                const checkbox = document.querySelector(`#checkbox-group-${plotConfig.plotId} input[value="${col}"]`);
                                if (checkbox) {
                                    checkbox.checked = true;
                                }
                            });
                            document.getElementById(`group-by-${plotConfig.plotId}`).value = plotConfig.controls.groupBy;
                        }

                        // Restore selected assay types
                        const assayTypeCheckboxes = document.querySelectorAll(
                            `#assay-type-checkboxes-${plotConfig.plotId} input[name="assay-type-${plotConfig.plotId}"]`
                        );
                        assayTypeCheckboxes.forEach(checkbox => {
                            checkbox.checked = plotConfig.controls.selectedAssayTypes.includes(checkbox.value);
                        });

                        // Set plot filters from session data
                        plotFilters[plotConfig.plotId] = plotConfig.filters || [];

                        // Update the plot
                        updatePlot(plotConfig.plotId);
                    });

                    // After all data is loaded and plots are restored, set selectedPoints
                    const sessionSelectedIds = sessionData.selectedPoints;

                    let userDataIds = [];
                    if (userData) {
                        userDataIds = userData.map(row => {
                            if (row['Experiment ID']) {
                                return 'user_' + row['Experiment ID'];
                            } else {
                                return 'user_' + row._uniqueId;
                            }
                        });
                    }

                    const allSelectedIds = sessionSelectedIds.concat(userDataIds);

                    selectedPoints = data.filter(row => allSelectedIds.includes(row._uniqueId));

                    // Update the table and highlight selected points
                    updateTable();
                    highlightSelectedPoints();

                    // Show notification
                    showNotification('Session imported successfully.');

                    // Hide loading modal
                    document.getElementById('loading-modal').style.display = 'none';
                }, false);
            }
            catch (error) {
                showNotification('Error importing session.', 'error');
                console.error('Error importing session:', error);
                document.getElementById('loading-modal').style.display = 'none';
            }
        }

        function integrateUserData(userDataArray, chunkSize = 1000) {
            // Safety Check: Ensure 'data' is an array
            if (!Array.isArray(data)) {
                console.error('Global variable "data" is not initialized as an array. Current value:', data);
                data = [];
            }

            // Create a map for existing data by 'Experiment ID' for quick lookup
            const existingDataMap = new Map();
            data.forEach(row => {
                if (row['Experiment ID']) {
                    existingDataMap.set(row['Experiment ID'], row);
                }
            });

            // Initialize an array to hold new experiments
            const newExperimentsList = [];

            for (let i = 0; i < userDataArray.length; i += chunkSize) {
                const chunk = userDataArray.slice(i, i + chunkSize);

                chunk.forEach(userRow => {
                    const experimentId = userRow['Experiment ID'];

                    if (experimentId && existingDataMap.has(experimentId)) {
                        // Existing Experiment ID found, check for updates
                        const existingRow = existingDataMap.get(experimentId);
                        let wasUpdated = false;

                        Object.entries(userRow).forEach(([key, value]) => {
                            if (key === 'Experiment ID') {
                                return; // Skip the Experiment ID field
                            }

                            if (!(key in existingRow)) {
                                // New column added
                                existingRow[key] = value;
                                wasUpdated = true;
                            } else if (existingRow[key] !== value && value !== null && value !== '') {
                                // Existing column value updated
                                existingRow[key] = value;
                                wasUpdated = true;
                            }
                        });

                        if (wasUpdated) {
                            uploadStats.totalUpdatedExperiments++;
                        }
                    } else {
                        // No existing Experiment ID, add as a new entry
                        if (experimentId) {
                            userRow._uniqueId = 'user_' + experimentId;
                        } else {
                            // Generate a unique ID if 'Experiment ID' is missing
                            userRow._uniqueId = 'user_' + Math.random().toString(36).substr(2, 9);
                        }
                        userRow._isUserData = true;

                        // Assign 'Unknown' to missing 'Assay type'
                        if (!userRow['Assay type']) {
                            userRow['Assay type'] = 'Unknown';
                        }

                        // Add the new row to data
                        data.push(userRow);
                        if (experimentId) {
                            existingDataMap.set(experimentId, userRow);
                            uploadStats.totalNewExperiments++;
                            // Add to newExperimentsList
                            newExperimentsList.push(userRow);
                        }
                    }
                });

                console.log(`Integrated ${i + chunk.length} / ${userDataArray.length} records.`);
            }

            console.log('Data integration complete. Total records:', data.length);

            return newExperimentsList;
        }




        function exportSessionToURL() {
            const sessionData = collectSessionData();
            const jsonData = JSON.stringify(sessionData);
            const compressedData = LZString.compressToEncodedURIComponent(jsonData);
            const newURL = window.location.protocol + "//" + window.location.host + window.location.pathname + '?session=' + compressedData;
            const sessionUrlInput = document.getElementById('session-url-input');
            sessionUrlInput.value = newURL;
            const exportSessionUrlModal = document.getElementById('export-session-url-modal');
            exportSessionUrlModal.style.display = 'flex';
        }


        // --------------------------------------------
        // Plot information modal
        // --------------------------------------------


        let operationsLog = [];
        const plotViewRanges = {};
        function logOperation(plotId, message) {
            const entry = { plotId: plotId, message: message };
            if (!operationsLog.some(e => e.plotId === plotId && e.message === message)) {
                operationsLog.push(entry);
            }
        }

        function showPlotInfo(plotId) {
            const modal = document.getElementById('plot-info-modal');
            const modalTitle = document.getElementById('plot-info-title');
            const modalContent = document.getElementById('plot-info-content');
            const closeBtn = document.getElementById('plot-info-modal-close');

            modalTitle.textContent = `Plot Information - ${plotId}`;

            const plotOperationsLog = operationsLog.filter(entry => entry.plotId === plotId);
            const uniqueLogEntries = [...new Set(plotOperationsLog.map(entry => entry.message))];
            const parameters = collectPlotParameters(plotId);

            // Build the content HTML with semantic structure and collapsible operations log
            let contentHTML = `
                <div class="parameters-section">
                    <h3>Parameters</h3>
                    <pre>${JSON.stringify(parameters, null, 2)}</pre>
                </div>
                <div class="operations-section">
                    <h3>
                        Operations Log
                        <button class="btn btn-sm btn-link" type="button" data-toggle="collapse" data-target="#operations-log-${plotId}" aria-expanded="false" aria-controls="operations-log-${plotId}">
                            <i class="fa fa-chevron-down"></i>
                        </button>
                    </h3>
                    <div class="collapse" id="operations-log-${plotId}">
                        <ul>
                            ${uniqueLogEntries.map(logEntry => `<li>${logEntry}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="mt-2">
                        <button id="export-json-${plotId}" class="btn btn-primary btn-sm mr-2">Export JSON</button>
                        <button id="copy-json-${plotId}" class="btn btn-secondary btn-sm">Copy JSON</button>
                    </div>
                </div>
            `;

            // Display content
            modalContent.innerHTML = contentHTML;
            modal.style.display = 'flex';

            // Setup event listeners for Export JSON and Copy JSON buttons
            const exportJsonBtn = document.getElementById(`export-json-${plotId}`);
            const copyJsonBtn = document.getElementById(`copy-json-${plotId}`);

            exportJsonBtn.addEventListener('click', () => {
                const jsonStr = JSON.stringify(parameters, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${plotId}_parameters.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            copyJsonBtn.addEventListener('click', () => {
                const jsonStr = JSON.stringify(parameters, null, 2);
                navigator.clipboard.writeText(jsonStr).then(() => {
                    alert('Plot parameters copied to clipboard!');
                }).catch(err => {
                    console.error('Could not copy text: ', err);
                    alert('Failed to copy parameters.');
                });
            });

            // Setup event listeners for modal close
            const handleClose = () => {
                modal.style.display = 'none';
                // Remove event listeners when modal is closed
                closeBtn.removeEventListener('click', handleClose);
                window.removeEventListener('click', handleClickOutside);
                window.removeEventListener('keydown', handleEscKey);
            };

            const handleClickOutside = (event) => {
                if (event.target === modal) {
                    handleClose();
                }
            };

            const handleEscKey = (event) => {
                if (event.key === 'Escape') {
                    handleClose();
                }
            };

            // Add event listeners
            closeBtn.addEventListener('click', handleClose);
            window.addEventListener('click', handleClickOutside);
            window.addEventListener('keydown', handleEscKey);
        }


        function collectPlotParameters(plotId) {
            const plotType = document.getElementById(`plot-type-${plotId}`).value;
            const parameters = {
                plotType: plotType,
                controls: {},
                title: document.getElementById(`title-${plotId}`).value,
                notes: document.getElementById(`notes-${plotId}`).value,
                filters: plotFilters[plotId] ? plotFilters[plotId] : []
            };

            // Collect control values based on plot type
            if (plotType === 'scatter') {
                parameters.controls.xAxis = document.getElementById(`x-axis-${plotId}`).value;
                parameters.controls.yAxis = document.getElementById(`y-axis-${plotId}`).value;
                parameters.controls.hue = document.getElementById(`hue-${plotId}`).value;
                parameters.controls.xLogScale = document.getElementById(`x-log-scale-${plotId}`).checked;
                parameters.controls.yLogScale = document.getElementById(`y-log-scale-${plotId}`).checked;
                parameters.controls.palette = document.getElementById(`palette-${plotId}`).value;

                // Range sliders
                const xSlider = document.getElementById(`x-range-slider-${plotId}`);
                const ySlider = document.getElementById(`y-range-slider-${plotId}`);
                const hueSlider = document.getElementById(`hue-range-slider-${plotId}`);

                if (xSlider && xSlider.noUiSlider) {
                    const [xMin, xMax] = xSlider.noUiSlider.get().map(Number);
                    parameters.controls.xRange = { min: xMin, max: xMax };
                }
                if (ySlider && ySlider.noUiSlider) {
                    const [yMin, yMax] = ySlider.noUiSlider.get().map(Number);
                    parameters.controls.yRange = { min: yMin, max: yMax };
                }
                if (hueSlider && hueSlider.noUiSlider) {
                    const [hueMin, hueMax] = hueSlider.noUiSlider.get().map(Number);
                    parameters.controls.hueRange = { min: hueMin, max: hueMax };
                }
            } else if (plotType === 'histogram' || plotType === 'boxplot') {
                parameters.controls.numColumns = Array.from(
                    document.querySelectorAll(`#checkbox-group-${plotId} input[name="num-columns-${plotId}"]:checked`)
                ).map(checkbox => checkbox.value);
                parameters.controls.groupBy = document.getElementById(`group-by-${plotId}`).value;
            }

            // Collect selected assay types
            parameters.controls.selectedAssayTypes = Array.from(
                document.querySelectorAll(`#assay-type-checkboxes-${plotId} input[name="assay-type-${plotId}"]:checked`)
            ).map(checkbox => checkbox.value);

            return parameters;
        }

    </script>

    <!-- Import Session Modal -->
    <div id="import-session-modal" class="modal">
        <div class="modal-content">
            <span id="import-session-close" class="close-button">&times;</span>
            <h2>Import Session</h2>
            <p>You can upload a session JSON file or paste the session data below.</p>
            <input type="file" id="session-file-input" accept=".json">
            <textarea id="session-textarea" placeholder="Paste session JSON data here..." rows="10"
                style="width: 100%;"></textarea>
            <button id="import-session-confirm" class="button">Import Session</button>
        </div>
    </div>

    <!-- Export Session URL Modal -->
    <div id="export-session-url-modal" class="modal">
        <div class="modal-content">
            <span id="export-session-url-close" class="close-button">&times;</span>
            <h2>Shareable Session URL</h2>
            <p>You can copy the URL below to share your session.</p>
            <input type="text" id="session-url-input" readonly style="width: 100%; font-size: 14px; padding: 10px;">
            <button id="copy-session-url" class="button">Copy to Clipboard</button>
        </div>
    </div>

    <!-- Loading Modal -->
    <div id="loading-modal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <div class="spinner"></div>
            <p>Please wait...</p>
        </div>
    </div>

    <!-- Upload Data Modal -->
    <div id="upload-data-modal" class="modal">
        <div class="modal-content">
            <span id="upload-data-close" class="close-button">&times;</span>
            <h2>Upload Custom Data</h2>
            <p>You can upload a custom TSV file containing your data.</p>
            <input type="file" id="upload-data-file-input" accept=".tsv,.txt">
            <p>
                <label>
                    <input type="radio" name="upload-data-mode" value="replace" checked>
                    Plot only my data
                </label>
                <label>
                    <input type="radio" name="upload-data-mode" value="append">
                    Append to current data
                </label>
            </p>
            <button id="upload-data-confirm" class="button">Upload Data</button>
        </div>
    </div>

    <div id="search-result-modal" class="modal">
        <div class="modal-content">
            <span class="close" id="search-result-close">&times;</span>
            <h2 id="search-result-title"></h2>
            <p id="search-result-message"></p>
        </div>
    </div>

    <!-- Filter Modal -->
    <div id="filter-modal" class="modal">
        <div class="modal-content">
            <span id="filter-modal-close" class="close-button">&times;</span>
            <h2>Apply Filters</h2>
            <div id="filter-groups-container">
                <!-- Filter groups will be dynamically added here -->
            </div>
            <button id="add-filter-group" class="button">Add Filter Group</button>
            <button id="apply-filters" class="button">Apply Filters</button>
        </div>
    </div>

    <!-- Plot Info Modal -->
    <div id="plot-info-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="plot-info-title">Plot Information</h2>
                <button class="close-button" id="plot-info-modal-close" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body">
                <div id="plot-info-content">
                    <!-- Dynamic content will be inserted here -->
                </div>
            </div>
        </div>
    </div>



    <div id="notification-container" style="position: fixed; top: 20px; right: 20px; z-index: 10000;"></div>


    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>
</body>