<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snipe Investigation Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.18.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }

        .container {
            background-color: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 1200px;
            margin: 2rem auto;
        }

        h1,
        h2 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 2rem;
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        h2 {
            font-size: 1.8rem;
            margin-top: 2rem;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            /* Align the controls to the top to ensure they are at the same level */
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        .control-group {
            flex: 1;
            margin-right: 1rem;
            min-width: 150px;
            display: flex;
            flex-direction: column;
        }

        .control-group:last-child {
            margin-right: 0;
        }

        .control-group label {
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
        }

        .control-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background-color: #fff;
            font-size: 1rem;
            color: #495057;
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        .control-group select:focus {
            border-color: #80bdff;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        select[multiple] {
            height: auto;
        }

        /* Adjust the plot container to accommodate the controls */
        .plot-container {
            margin-top: 1rem;
            margin-bottom: 3rem;
            background-color: #ffffff;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                margin-right: 0;
                margin-bottom: 1rem;
            }

            .control-group:last-child {
                margin-bottom: 0;
            }
        }

        .scrollable-checkboxes {
            max-height: 150px;
            /* Set a fixed height */
            overflow-y: auto;
            /* Enable vertical scrolling */
            padding: 5px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background-color: #ffffff;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
        }

        .checkbox-item {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
        }

        .checkbox-item input {
            margin-right: 0.5rem;
        }



        label {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #34495e;
        }

        select {
            padding: 10px;
            font-size: 16px;
            border-radius: 8px;
            border: 1px solid #bdc3c7;
            background-color: #ecf0f1;
            transition: all 0.3s ease;
        }

        select:focus {
            outline: none;
            box-shadow: 0 0 0 2px #3498db;
        }

        .plot {
            width: 100%;
            height: 600px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        .table-container {
            width: 100%;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 2rem;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #plots-container {
            margin-bottom: 2rem;
        }

        #data-selection-section {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 2px solid #3498db;
        }

        #table-container {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .additional-inputs {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #f9fbfd;
            border: 1px solid #dce1e6;
            border-radius: 8px;
        }

        .title-input,
        .notes-textarea {
            width: 100%;
            padding: 12px;
            font-size: 14px;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            transition: all 0.3s ease;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .title-input:focus,
        .notes-textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
        }

        .notes-textarea {
            min-height: 100px;
            resize: vertical;
        }





        .notes-container label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .search-container {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        #search-input {
            flex: 1;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            margin-right: 10px;
        }

        #search-button {
            padding: 10px 20px;
            font-size: 16px;
            color: white;
            background-color: #3498db;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #search-button:hover {
            background-color: #2980b9;
        }

        .export-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
        }

        /* Enhanced button styles */
        .button {
            padding: 10px 20px;
            font-size: 14px;
            color: white;
            background-color: #3498db;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .button:hover {
            background-color: #2980b9;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
        }

        .button::before {
            font-family: "Font Awesome 5 Free";
            font-weight: 900;
            margin-right: 8px;
        }

        #add-view {
            background-color: #2ecc71;
        }

        #add-view:hover {
            background-color: #27ae60;
        }

        #add-view::before {
            content: "\f067";
            /* Plus icon */
        }

        #clear-selections {
            background-color: #e74c3c;
        }

        #clear-selections:hover {
            background-color: #c0392b;
        }

        #clear-selections::before {
            content: "\f12d";
            /* Eraser icon */
        }

        #export-table {
            background-color: #f39c12;
        }

        #export-table:hover {
            background-color: #d35400;
        }

        #export-table::before {
            content: "\f56e";
            /* File export icon */
        }

        #export-pdf {
            background: linear-gradient(-45deg, #405de6, #5851db, #833ab4, #c13584);
            background-size: 400% 400%;
            animation: gradientAnimation 15s ease infinite;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #export-pdf:hover {
            background-size: 200% 200%;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }

        #export-pdf::before {
            content: "\f1c1";
            /* File PDF icon */
        }

        #scroll-to-table {
            background-color: #9b59b6;
        }

        #scroll-to-table:hover {
            background-color: #8e44ad;
        }

        #scroll-to-table::before {
            content: "\f13d";
            /* Anchor icon */
        }

        .floating-buttons {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .floating-buttons .button {
            width: 180px;
            text-align: center;
            padding: 12px 16px;
            margin: 0;
            font-size: 13px;
        }

        @keyframes gradientAnimation {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Snipe Investigation Dashboard</h1>
        <div id="plots-container"></div>
        <div class="export-buttons">
            <button id="add-view" class="button">Add View</button>
        </div>
        <!-- <div class="export-buttons">
            <button id="add-view" class="button">Add View</button>
            <button id="clear-selections" class="button">Clear Selections</button>
            <button id="export-table" class="button">Export Table (TSV)</button>
        </div>
    -->
        <div id="data-selection-section">
            <h2>Selected Data Points</h2>
            <!-- <button id="export-pdf">Export Snipe Report</button> -->
            <div id="table-container" class="table-container"></div>
        </div>
    </div>


    <div class="floating-buttons">
        <!-- <button id="add-view" class="button">Add View</button> -->
        <button id="clear-selections" class="button">Clear Selections</button>
        <button id="export-table" class="button">Export Table (TSV)</button>
        <button id="export-pdf" class="button">Export Snipe Report</button>
        <button id="scroll-to-table" class="button">Scroll to Table</button>
    </div>


    <script>
        let data;
        let currentPlotData;
        let selectedPoints = [];
        let plotsContainer, tableContainer, exportTableButton, clearSelectionsButton, addViewButton;
        let plotCounter = 0;

        document.addEventListener('DOMContentLoaded', function () {
            plotsContainer = document.getElementById('plots-container');
            tableContainer = document.getElementById('table-container');
            exportTableButton = document.getElementById('export-table');
            clearSelectionsButton = document.getElementById('clear-selections');
            addViewButton = document.getElementById('add-view');

            loadData();

            exportTableButton.addEventListener('click', exportTableToTSV);
            clearSelectionsButton.addEventListener('click', clearSelections);
            addViewButton.addEventListener('click', addNewPlot);
            document.getElementById('export-pdf').addEventListener('click', exportAllDataAsPDF);
            document.getElementById('scroll-to-table').addEventListener('click', scrollToTable);
        });

        function scrollToTable() {
            const tableSection = document.getElementById('data-selection-section');
            tableSection.scrollIntoView({ behavior: 'smooth' });
        }

        const hoverColumns = [
            "Experiment", "Assay Type", "BioSample", "BioProject",
            "Alignment-free genome coverage index",
            "Genomic k-mers mean abundance",
            "Alignment-free exome coverage index",
            "Exome k-mers mean abundance",
            "X Ploidy score",
            "Y Coverage score",
            "Predicted Contamination Index",
            "Fraction of Singleton K-mers Total Abundance",
            "Fraction of Non-Reference Duplicate K-mers Total Abundance",
            "Fraction of Non-Reference K-mers Total Abundance",
        ];


        function loadData() {
            Papa.parse("data/snipe_metadata.tsv", {
                download: true,
                header: true,
                delimiter: "\t",
                complete: function (results) {
                    data = results.data;

                    // Assign a unique ID to each data point
                    data.forEach((row, index) => {
                        row._uniqueId = index.toString(); // Ensure ID is a string
                    });

                    addNewPlot();
                }
            });
        }

        function addNewPlot() {
            plotCounter++;
            const plotId = `plot-${plotCounter}`;
            let plotHTML = '';

            // If this is the first plot, add the search bar at the top
            if (plotCounter === 1) {
                plotHTML += `
                    <div class="search-container">
                        <input type="text" id="search-input" placeholder="Search...">
                        <button id="search-button" class="button">Search</button>
                    </div>
                `;
            }

            plotHTML += `
                <div class="plot-container">
                    <div class="controls">
                        <!-- Plot Type Control -->
                        <div class="control-group">
                            <label for="plot-type-${plotId}">Plot Type:</label>
                            <select id="plot-type-${plotId}">
                                <option value="scatter">Scatter Plot</option>
                                <option value="histogram">Histogram</option>
                                <option value="boxplot">Boxplot</option>
                            </select>
                        </div>
                        <!-- Dynamic Controls -->
                        <div id="dynamic-controls-${plotId}" class="controls"></div>
                    </div>
                    <div id="${plotId}" class="plot"></div>
                    <button id="export-plot-${plotId}" class="button">Export Plot (300 DPI PNG)</button>
                    <div class="additional-inputs">
                        <div class="control-group">
                            <label for="title-${plotId}">Plot Title:</label>
                            <input type="text" id="title-${plotId}" class="title-input" placeholder="Enter plot title...">
                        </div>
                        <div class="control-group">
                            <label for="notes-${plotId}">Notes:</label>
                            <textarea id="notes-${plotId}" class="notes-textarea" placeholder="Enter your notes here..."></textarea>
                        </div>
                    </div>
                </div>
            `;

            plotsContainer.insertAdjacentHTML('beforeend', plotHTML);

            const plotTypeSelect = document.getElementById(`plot-type-${plotId}`);
            const exportPlotButton = document.getElementById(`export-plot-${plotId}`);

            plotTypeSelect.addEventListener('change', () => renderDynamicControls(plotId));

            // Render controls initially
            renderDynamicControls(plotId);

            exportPlotButton.addEventListener('click', () => exportPlot(plotId));

            // Attach event listener to the search button if this is the first plot
            if (plotCounter === 1) {
                document.getElementById('search-button').addEventListener('click', searchAndSelectPoints);
            }
        }

        function renderDynamicControls(plotId) {
            const plotType = document.getElementById(`plot-type-${plotId}`).value;
            const dynamicControlsDiv = document.getElementById(`dynamic-controls-${plotId}`);

            // Exclude columns starting with '_' from the dropdowns
            const columns = Object.keys(data[0]).filter(col => !col.startsWith('_'));
            const numericalColumns = columns.filter(col => data.some(row => isNumeric(row[col])));
            const categoricalColumns = columns.filter(col => !numericalColumns.includes(col));

            _cols_to_exclude_from_color = ['Experiment'];
            const cols_for_colorby = columns.filter(col => !_cols_to_exclude_from_color.includes(col));

            let controlsHTML = '';

            if (plotType === 'scatter') {
                controlsHTML = `
                    <div class="control-group">
                        <label for="x-axis-${plotId}">X-Axis:</label>
                        <select id="x-axis-${plotId}">
                            <option value="">Select X-Axis</option>
                            <!-- ${columns.map(col => `<option value="${col}">${col}</option>`).join('')} -->
                            ${numericalColumns.map(col => `<option value="${col}">${col}</option>`).join('')}
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="y-axis-${plotId}">Y-Axis:</label>
                        <select id="y-axis-${plotId}">
                            <option value="">Select Y-Axis</option>
                            ${numericalColumns.map(col => `<option value="${col}">${col}</option>`).join('')}
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="hue-${plotId}">Color By:</label>
                        <select id="hue-${plotId}">
                            <option value="">Select Color</option>
                            ${cols_for_colorby.map(col => `<option value="${col}">${col}</option>`).join('')}
                        </select>
                    </div>
                `;
            } else if (plotType === 'boxplot' || plotType === 'histogram') {
                // Use checkboxes for selecting numerical columns, wrapped in a scrollable box
                controlsHTML = `
                    <div class="control-group">
                        <label>Select Numerical Columns:</label>
                        <div id="checkbox-group-${plotId}" class="checkbox-group scrollable-checkboxes">
                            ${numericalColumns.map(col => `
                                <div class="checkbox-item">
                                    <input type="checkbox" id="num-column-${col}-${plotId}" name="num-columns-${plotId}" value="${col}">
                                    <label for="num-column-${col}-${plotId}">${col}</label>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="group-by-${plotId}">Group By (Optional):</label>
                        <select id="group-by-${plotId}">
                            <option value="">No Grouping</option>
                            ${categoricalColumns.map(col => `<option value="${col}">${col}</option>`).join('')}
                        </select>
                    </div>
                `;
            }

            // Common control for Assay Type
            controlsHTML += `
                <div class="control-group">
                    <label for="assay-type-${plotId}">Assay Type:</label>
                    <select id="assay-type-${plotId}">
                        <option value="">All Assay Types</option>
                        ${[...new Set(data.map(row => row["Assay Type"]))].map(type => `<option value="${type}">${type}</option>`).join('')}
                    </select>
                </div>
            `;

            dynamicControlsDiv.innerHTML = controlsHTML;

            // Attach event listeners to new controls
            const controls = dynamicControlsDiv.querySelectorAll('select, input[type=checkbox]');
            controls.forEach(control => {
                control.addEventListener('change', () => updatePlot(plotId));
            });

            // For better UX, automatically update the plot when controls are rendered
            updatePlot(plotId);
        }




        function searchAndSelectPoints() {
            const searchInput = document.getElementById('search-input');
            const searchText = searchInput.value.trim().toLowerCase();

            if (searchText === '') {
                return;
            }

            const matchingPoints = data.filter(row => {
                return ['BioProject', 'BioSample', 'Experiment', 'biosample_experiment'].some(col => {
                    return row[col] && row[col].toString().toLowerCase().includes(searchText);
                });
            });

            if (matchingPoints.length === 0) {
                return;
            }

            matchingPoints.forEach(point => {
                if (!selectedPoints.some(p => p._uniqueId === point._uniqueId)) {
                    selectedPoints.push(point);
                }
            });

            updateTable();
            highlightSelectedPoints();
        }




        function isNumeric(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }



        function updatePlot(plotId) {
            const plotDiv = document.getElementById(plotId);
            const plotType = document.getElementById(`plot-type-${plotId}`).value;
            const selectedAssayType = document.getElementById(`assay-type-${plotId}`).value;

            currentPlotData = selectedAssayType ? data.filter(row => row["Assay Type"] === selectedAssayType) : data;

            if (plotType === 'scatter') {
                const xAxis = document.getElementById(`x-axis-${plotId}`).value;
                const yAxis = document.getElementById(`y-axis-${plotId}`).value;
                const hueColumn = document.getElementById(`hue-${plotId}`).value;

                if (!xAxis || !yAxis || !hueColumn) {
                    plotDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Please select values for X-Axis, Y-Axis, and Color to generate the plot.</p>';
                    return;
                }

                const isHueNumeric = currentPlotData.some(row => isNumeric(row[hueColumn]));

                let traces;
                if (isHueNumeric) {
                    traces = [{
                        x: currentPlotData.map(row => row[xAxis]),
                        y: currentPlotData.map(row => row[yAxis]),
                        text: currentPlotData.map(row =>
                            hoverColumns.map(col => `${col}: ${row[col]}`).join('<br>')
                        ),
                        customdata: currentPlotData.map(row => row._uniqueId),
                        ids: currentPlotData.map(row => row._uniqueId),
                        mode: 'markers',
                        type: 'scatter',
                        marker: {
                            color: currentPlotData.map(row => parseFloat(row[hueColumn])),
                            colorscale: 'Spectral',
                            colorbar: { title: hueColumn },
                            size: 6
                        },
                        showlegend: false,
                        hoverinfo: 'text',
                        selected: {
                            marker: {
                                color: 'black',
                                size: 12,
                            }
                        }
                    }];
                } else {
                    const categories = [...new Set(currentPlotData.map(row => row[hueColumn]))];
                    traces = categories.map(category => {
                        const filteredData = currentPlotData.filter(row => row[hueColumn] === category);
                        return {
                            x: filteredData.map(row => row[xAxis]),
                            y: filteredData.map(row => row[yAxis]),
                            text: filteredData.map(row =>
                                hoverColumns.map(col => `${col}: ${row[col]}`).join('<br>')
                            ),
                            customdata: filteredData.map(row => row._uniqueId),
                            ids: filteredData.map(row => row._uniqueId),
                            mode: 'markers',
                            type: 'scatter',
                            name: category,
                            marker: {
                                size: 6
                            },
                            hoverinfo: 'text',
                            selected: {
                                marker: {
                                    color: 'black',
                                    size: 12
                                }
                            }
                        };
                    });
                }

                const layout = {
                    xaxis: { title: xAxis },
                    yaxis: { title: yAxis },
                    hovermode: 'closest',
                    showlegend: true,
                    margin: { t: 50 },
                    plot_bgcolor: '#f8f9fa',
                    paper_bgcolor: '#f8f9fa'
                };

                Plotly.newPlot(plotDiv, traces, layout).then(() => {
                    plotDiv.on('plotly_click', (eventData) => onPointClick(eventData, plotId));
                    highlightSelectedPoints();
                });

            } else if (plotType === 'histogram') {
                // Updated retrieval of selected numerical columns
                const numColumns = Array.from(document.querySelectorAll(`#checkbox-group-${plotId} input[name="num-columns-${plotId}"]:checked`)).map(checkbox => checkbox.value);
                const groupBy = document.getElementById(`group-by-${plotId}`).value;

                if (numColumns.length === 0) {
                    plotDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Please select at least one numerical column to generate the histogram.</p>';
                    return;
                }

                let traces = [];

                numColumns.forEach(numCol => {
                    if (groupBy) {
                        const categories = [...new Set(currentPlotData.map(row => row[groupBy]))];

                        categories.forEach(category => {
                            const filteredData = currentPlotData.filter(row => row[groupBy] === category);
                            traces.push({
                                x: filteredData.map(row => parseFloat(row[numCol])),
                                type: 'histogram',
                                name: `${numCol} - ${category}`,
                                opacity: 0.75,
                                marker: { opacity: 0.75 },
                                hoverinfo: 'x+y',
                            });
                        });
                    } else {
                        traces.push({
                            x: currentPlotData.map(row => parseFloat(row[numCol])),
                            type: 'histogram',
                            name: numCol,
                            opacity: 0.75,
                            marker: { opacity: 0.75 },
                            hoverinfo: 'x+y',
                        });
                    }
                });

                const layout = {
                    xaxis: { title: 'Value' },
                    yaxis: { title: 'Count' },
                    barmode: groupBy ? 'group' : 'overlay',
                    margin: { t: 50 },
                    plot_bgcolor: '#f8f9fa',
                    paper_bgcolor: '#f8f9fa'
                };

                Plotly.newPlot(plotDiv, traces, layout);

            } else if (plotType === 'boxplot') {
                // Updated retrieval of selected numerical columns
                const numColumns = Array.from(document.querySelectorAll(`#checkbox-group-${plotId} input[name="num-columns-${plotId}"]:checked`)).map(checkbox => checkbox.value);
                const groupBy = document.getElementById(`group-by-${plotId}`).value;

                if (numColumns.length === 0) {
                    plotDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Please select at least one numerical column to generate the boxplot.</p>';
                    return;
                }

                let traces = [];

                numColumns.forEach(numCol => {
                    if (groupBy) {
                        const categories = [...new Set(currentPlotData.map(row => row[groupBy]))];

                        categories.forEach(category => {
                            const filteredData = currentPlotData.filter(row => row[groupBy] === category);

                            traces.push({
                                y: filteredData.map(row => parseFloat(row[numCol])),
                                type: 'box',
                                name: `${numCol} - ${category}`,
                                boxpoints: 'outliers',
                                hoverinfo: 'y',
                            });
                        });
                    } else {
                        traces.push({
                            y: currentPlotData.map(row => parseFloat(row[numCol])),
                            type: 'box',
                            name: numCol,
                            boxpoints: 'outliers',
                            hoverinfo: 'y',
                        });
                    }
                });

                const layout = {
                    yaxis: { title: 'Value' },
                    xaxis: { title: 'Variables' },
                    margin: { t: 50 },
                    plot_bgcolor: '#f8f9fa',
                    paper_bgcolor: '#f8f9fa'
                };

                Plotly.newPlot(plotDiv, traces, layout);

            } else {
                plotDiv.innerHTML = '<p style="text-align: center; color: #e74c3c;">Invalid plot type selected.</p>';
            }
        }


        function onPointClick(eventData, plotId) {
            const pt = eventData.points[0];
            const clickedId = pt.customdata;

            const clickedPoint = data.find(row => row._uniqueId === clickedId);

            if (!clickedPoint) return;

            const index = selectedPoints.findIndex(p => p._uniqueId === clickedId);

            if (index === -1) {
                selectedPoints.push(clickedPoint);
            } else {
                selectedPoints.splice(index, 1);
            }
            updateTable();
            highlightSelectedPoints();
        }

        function highlightSelectedPoints() {
            const selectedIds = new Set(selectedPoints.map(p => p._uniqueId));

            // Use requestAnimationFrame for better performance
            requestAnimationFrame(() => {
                for (let i = 1; i <= plotCounter; i++) {
                    const plotId = `plot-${i}`;
                    const plotDiv = document.getElementById(plotId);
                    if (plotDiv && plotDiv.data) {
                        const update = { selectedpoints: [] };
                        plotDiv.data.forEach((trace) => {
                            const selectedIndices = [];
                            if (trace.ids) {
                                trace.ids.forEach((id, index) => {
                                    if (selectedIds.has(id)) {
                                        selectedIndices.push(index);
                                    }
                                });
                                update.selectedpoints.push(selectedIndices);
                            } else {
                                update.selectedpoints.push(null);
                            }
                        });
                        Plotly.restyle(plotDiv, update);
                    }
                }
            });
        }


        function updateTable() {
            if (selectedPoints.length === 0) {
                tableContainer.innerHTML = '<p>No points selected. Click on points in the plot to add them to the table.</p>';
                return;
            }

            const columns = Object.keys(selectedPoints[0]).filter(col => !col.startsWith('_'));
            let tableHTML = '<table><tr>';
            columns.forEach(col => {
                tableHTML += `<th>${col}</th>`;
            });
            tableHTML += '</tr>';

            selectedPoints.forEach(point => {
                tableHTML += '<tr>';
                columns.forEach(col => {
                    tableHTML += `<td>${point[col]}</td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += '</table>';
            tableContainer.innerHTML = tableHTML;
        }

        function clearSelections() {
            selectedPoints = [];
            updateTable();
            highlightSelectedPoints();
        }

        function exportTableToTSV() {
            if (selectedPoints.length === 0) {
                alert('No data to export. Please select some points first.');
                return;
            }

            const columns = Object.keys(selectedPoints[0]).filter(col => !col.startsWith('_'));
            let csvContent = columns.join('\t') + '\n';

            selectedPoints.forEach(point => {
                const row = columns.map(col => point[col]).join('\t');
                csvContent += row + '\n';
            });

            const blob = new Blob([csvContent], { type: 'text/tab-separated-values;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'selected_points.tsv';
            link.click();
        }

        function exportPlot(plotId) {
            const plotDiv = document.getElementById(plotId);
            Plotly.toImage(plotDiv, { format: 'png', width: 1200, height: 800 }).then(function (dataUrl) {
                const link = document.createElement('a');
                link.download = `${plotId}.png`;
                link.href = dataUrl;
                link.click();
            });
        }

        function exportAllDataAsPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('portrait', 'pt', 'a4');
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();

            // Add Company Logo (Replace 'logo.png' with your logo file path)
            const logoImg = new Image();
            logoImg.src = 'https://avatars.githubusercontent.com/u/163611200?s=400&u=d20c621ec8b0ebe1bb072c19b26726e95712d971&v=4'; // Ensure the logo is accessible
            logoImg.onload = () => {
                doc.addImage(logoImg, 'PNG', 40, 40, 100, 50);

                // Cover Page
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(24);
                doc.text("Snipe Investigation Dashboard", pageWidth / 2, 120, null, null, 'center');

                // Date and Time
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(12);
                doc.text(`Export Date: ${new Date().toLocaleString()}`, pageWidth / 2, 140, null, null, 'center');

                // Move to next page for TOC
                doc.addPage();

                // Table of Contents
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(18);
                doc.text("Table of Contents", 40, 80);

                let tocYPosition = 110;
                const plotPageNumbers = [];

                // Collect promises for images and build TOC
                const promises = [];
                for (let i = 1; i <= plotCounter; i++) {
                    const plotId = `plot-${i}`;
                    const plotDiv = document.getElementById(plotId);
                    const plotTitleInput = document.getElementById(`title-${plotId}`);
                    const plotTitle = plotTitleInput && plotTitleInput.value.trim() !== '' ? plotTitleInput.value : `Plot ${i}`;
                    const pageNum = doc.internal.getNumberOfPages() + promises.length + 1;
                    plotPageNumbers.push(pageNum);

                    // Add entry to TOC
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(12);
                    doc.text(plotTitle, 60, tocYPosition);
                    doc.text(`Page ${pageNum}`, pageWidth - 60, tocYPosition, null, null, 'right');
                    tocYPosition += 20;

                    if (tocYPosition > pageHeight - 80) {
                        doc.addPage();
                        tocYPosition = 80;
                    }

                    if (plotDiv) {
                        const promise = Plotly.toImage(plotDiv, { format: 'png', width: 1200, height: 800 })
                            .then(function (dataUrl) {
                                // Add a new page for the plot
                                doc.addPage();

                                // Add plot title
                                doc.setFont('helvetica', 'bold');
                                doc.setFontSize(16);
                                doc.text(plotTitle, pageWidth / 2, 50, null, null, 'center');

                                // Add plot image
                                const imgWidth = pageWidth - 80;
                                const imgHeight = (imgWidth * 800) / 1200; // Maintain aspect ratio
                                doc.addImage(dataUrl, 'PNG', 40, 70, imgWidth, imgHeight);

                                // Add plot details
                                doc.setFont('helvetica', 'normal');
                                doc.setFontSize(12);
                                const plotType = document.getElementById(`plot-type-${plotId}`).value;
                                let detailsYPosition = 80 + imgHeight + 20;

                                // Add plot type
                                doc.text(`Plot Type: ${plotType}`, 60, detailsYPosition);

                                if (plotType === 'scatter') {
                                    const xAxisValue = document.getElementById(`x-axis-${plotId}`).value;
                                    const yAxisValue = document.getElementById(`y-axis-${plotId}`).value;
                                    const hueValue = document.getElementById(`hue-${plotId}`).value;
                                    doc.text(`X-Axis: ${xAxisValue}`, 60, detailsYPosition + 20);
                                    doc.text(`Y-Axis: ${yAxisValue}`, 60, detailsYPosition + 40);
                                    doc.text(`Color By: ${hueValue}`, 60, detailsYPosition + 60);
                                    // write a new line
                                    
                                } else if (plotType === 'histogram' || plotType === 'boxplot') {
                                    // Updated retrieval of selected numerical columns
                                    const numColumns = Array.from(document.querySelectorAll(`#checkbox-group-${plotId} input[name="num-columns-${plotId}"]:checked`)).map(checkbox => checkbox.value).join(', ');
                                    const groupBy = document.getElementById(`group-by-${plotId}`).value || 'None';
                                    doc.text(`Numerical Columns: ${numColumns}`, 60, detailsYPosition + 20);
                                    doc.text(`Group By: ${groupBy}`, 60, detailsYPosition + 40);
                                }

                                const assayTypeValue = document.getElementById(`assay-type-${plotId}`).value || 'All';
                                doc.text(`Assay Type: ${assayTypeValue}`, 60, detailsYPosition + 80);

                                // Add user's notes
                                const notesValue = document.getElementById(`notes-${plotId}`).value;
                                if (notesValue.trim() !== '') {
                                    doc.setFont('helvetica', 'bolditalic');
                                    doc.text("Notes:", 60, detailsYPosition + 90);
                                    doc.setFont('helvetica', 'normal');
                                    // Handle multi-line notes
                                    const lines = doc.splitTextToSize(notesValue, pageWidth - 120);
                                    doc.text(lines, 60, detailsYPosition + 110);
                                }
                            });
                        promises.push(promise);
                    }
                }

                // Add Selected Data Table if any points are selected
                /*
                if (selectedPoints.length > 0) {
                    const pageNum = doc.internal.getNumberOfPages() + promises.length + 1;
                    doc.setFont('helvetica', 'normal');
                    doc.setFontSize(12);
                    doc.text("Selected Data Points", 60, tocYPosition);
                    doc.text(`Page ${pageNum}`, pageWidth - 60, tocYPosition, null, null, 'right');

                    const promise = new Promise((resolve) => {
                        doc.addPage();
                        addSelectedDataTable(doc);
                        resolve();
                    });
                    promises.push(promise);
                }*/

                Promise.all(promises).then(() => {
                    // Add page numbers
                    const pageCount = doc.internal.getNumberOfPages();
                    for (let i = 1; i <= pageCount; i++) {
                        doc.setPage(i);
                        doc.setFontSize(10);
                        doc.text(`Page ${i} of ${pageCount}`, pageWidth / 2, pageHeight - 30, null, null, 'center');
                    }

                    // Save the PDF
                    doc.save("snipe_investigation_report.pdf");
                });
            };
        }




        function addSelectedDataTable(doc) {
            doc.addPage();
            doc.setFontSize(16);
            doc.text("Selected Data Points", 20, 20);

            const columns = Object.keys(selectedPoints[0]);
            let yOffset = 30;
            const pageWidth = doc.internal.pageSize.width;

            // Calculate column widths
            const columnWidths = columns.map(col =>
                Math.min(40, Math.max(...selectedPoints.map(row => doc.getTextWidth(String(row[col])))))
            );
            const totalWidth = columnWidths.reduce((a, b) => a + b, 0);
            const scaleFactor = (pageWidth - 40) / totalWidth;
            const scaledWidths = columnWidths.map(w => w * scaleFactor);

            // Add headers
            doc.setFontSize(10);
            doc.setTextColor(100);
            columns.forEach((col, index) => {
                doc.text(col, 20 + scaledWidths.slice(0, index).reduce((a, b) => a + b, 0), yOffset);
            });
            yOffset += 10;

            // Add data rows
            doc.setTextColor(0);
            selectedPoints.forEach((point, rowIndex) => {
                if (yOffset > 280) {
                    doc.addPage();
                    yOffset = 20;
                }
                columns.forEach((col, colIndex) => {
                    doc.text(String(point[col]), 20 + scaledWidths.slice(0, colIndex).reduce((a, b) => a + b, 0), yOffset);
                });
                yOffset += 7;
            });

            // Save the PDF
            doc.save("snipe_investigation_report.pdf");
        }
    </script>